<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Exiv2: Exiv2 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Exiv2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Exiv2 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides classes and functions to encode and decode Exif and Iptc data. The <b>libexiv2</b> API consists of the objects of this namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceExiv2_1_1ImageType"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2_1_1ImageType.html">ImageType</a></td></tr>
<tr class="memdesc:namespaceExiv2_1_1ImageType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported image formats. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceExiv2_1_1Internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2_1_1Internal.html">Internal</a></td></tr>
<tr class="memdesc:namespaceExiv2_1_1Internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains internal objects which are not published and are not part of the <b>libexiv2</b> API. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Converter.html">Converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata conversions.  <a href="classExiv2_1_1Converter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1MimeTypeList.html">MimeTypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for TIFF compression to MIME type mappings.  <a href="structExiv2_1_1MimeTypeList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1AsfVideo.html">AsfVideo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access ASF video files.  <a href="classExiv2_1_1AsfVideo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for simple binary IO.  <a href="classExiv2_1_1BasicIo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1IoCloser.html">IoCloser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that closes a <a class="el" href="classExiv2_1_1BasicIo.html" title="An interface for simple binary IO. ">BasicIo</a> instance upon destruction. Meant to be used as a stack variable in functions that need to ensure <a class="el" href="classExiv2_1_1BasicIo.html" title="An interface for simple binary IO. ">BasicIo</a> instances get closed. Useful when functions return errors from many locations.  <a href="classExiv2_1_1IoCloser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1FileIo.html">FileIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides binary file IO by implementing the <a class="el" href="classExiv2_1_1BasicIo.html" title="An interface for simple binary IO. ">BasicIo</a> interface.  <a href="classExiv2_1_1FileIo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1MemIo.html">MemIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides binary IO on blocks of memory by implementing the <a class="el" href="classExiv2_1_1BasicIo.html" title="An interface for simple binary IO. ">BasicIo</a> interface. A copy-on-write implementation ensures that the data passed in is only copied when necessary, i.e., as soon as data is written to the <a class="el" href="classExiv2_1_1MemIo.html" title="Provides binary IO on blocks of memory by implementing the BasicIo interface. A copy-on-write impleme...">MemIo</a>. The original data is only used for reading. If writes are performed, the changed data can be retrieved using the read methods (since the data used in construction is never modified).  <a href="classExiv2_1_1MemIo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1StdinIo.html">StdinIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading the data from stdin and provide <a class="el" href="classExiv2_1_1FileIo.html" title="Provides binary file IO by implementing the BasicIo interface. ">FileIo</a> or <a class="el" href="classExiv2_1_1MemIo.html" title="Provides binary IO on blocks of memory by implementing the BasicIo interface. A copy-on-write impleme...">MemIo</a> by inheriting from one of these classes.  <a href="classExiv2_1_1StdinIo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1BlockMap.html">BlockMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1RemoteIo.html">RemoteIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="classExiv2_1_1RemoteIo.html" title="Provides RemoteIo superclass by implementing the BasicIo. This class implements the blockMap which is...">RemoteIo</a> superclass by implementing the <a class="el" href="classExiv2_1_1BasicIo.html" title="An interface for simple binary IO. ">BasicIo</a>. This class implements the blockMap which is used by httpio, curlio, sshio.  <a href="classExiv2_1_1RemoteIo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1HttpIo.html">HttpIo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1CurlIo.html">CurlIo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1SshIo.html">SshIo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1BmpImage.html">BmpImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access Windows bitmaps. This is just a stub - we only read width and height.  <a href="classExiv2_1_1BmpImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Cr2Image.html">Cr2Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Canon CR2 images. Exif metadata is supported directly, IPTC is read from the Exif data, if present.  <a href="classExiv2_1_1Cr2Image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Cr2Parser.html">Cr2Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for data in CR2 format. Images use this class to decode and encode CR2 data. See class <a class="el" href="classExiv2_1_1TiffParser.html" title="Stateless parser class for data in TIFF format. Images use this class to decode and encode TIFF data...">TiffParser</a> for details.  <a href="classExiv2_1_1Cr2Parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1CrwImage.html">CrwImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Canon CRW images. Only Exif metadata and a comment are supported. CRW format does not contain IPTC metadata.  <a href="classExiv2_1_1CrwImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1CrwParser.html">CrwParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1RecordInfo.html">RecordInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of an IPTC record.  <a href="structExiv2_1_1RecordInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1DataSet.html">DataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of an IPTC dataset.  <a href="structExiv2_1_1DataSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1IptcDataSets.html">IptcDataSets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPTC dataset reference, implemented as a static class.  <a href="classExiv2_1_1IptcDataSets.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1IptcKey.html">IptcKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete keys for IPTC metadata.  <a href="classExiv2_1_1IptcKey.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1EpsImage.html">EpsImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access EPS images.  <a href="classExiv2_1_1EpsImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1LogMsg.html">LogMsg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a log message, used by the library. Applications can set the log level and provide a customer log message handler (callback function).  <a href="classExiv2_1_1LogMsg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1AnyError.html">AnyError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error class interface. Allows the definition and use of a hierarchy of error classes which can all be handled in one catch block. Inherits from the standard exception base-class, to make life easier for library users (they have the option of catching most things via std::exception).  <a href="classExiv2_1_1AnyError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1BasicError.html">BasicError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple error class used for exceptions. An output operator is provided to print errors to a stream.  <a href="classExiv2_1_1BasicError.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Exifdatum.html">Exifdatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Exif metadatum, consisting of an <a class="el" href="classExiv2_1_1ExifKey.html" title="Concrete keys for Exif metadata and access to Exif tag reference data. ">ExifKey</a> and a <a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> and methods to manipulate these.  <a href="classExiv2_1_1Exifdatum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifThumbC.html">ExifThumbC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to a Exif thumbnail image. This class provides higher level accessors to the thumbnail image that is optionally embedded in IFD1 of the Exif data. These methods do not write to the Exif metadata. Manipulators are provided in subclass <a class="el" href="classExiv2_1_1ExifThumb.html" title="Access and modify an Exif thumbnail image. This class implements manipulators to set and erase the th...">ExifThumb</a>.  <a href="classExiv2_1_1ExifThumbC.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifThumb.html">ExifThumb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access and modify an Exif thumbnail image. This class implements manipulators to set and erase the thumbnail image that is optionally embedded in IFD1 of the Exif data. Accessors are provided by the base class, <a class="el" href="classExiv2_1_1ExifThumbC.html" title="Access to a Exif thumbnail image. This class provides higher level accessors to the thumbnail image t...">ExifThumbC</a>.  <a href="classExiv2_1_1ExifThumb.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifData.html">ExifData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for Exif data. This is a top-level class of the Exiv2 library. The container holds <a class="el" href="classExiv2_1_1Exifdatum.html" title="An Exif metadatum, consisting of an ExifKey and a Value and methods to manipulate these...">Exifdatum</a> objects.  <a href="classExiv2_1_1ExifData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifParser.html">ExifParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for Exif data. Images use this class to decode and encode binary Exif data.  <a href="classExiv2_1_1ExifParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Uri.html">Uri</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1GifImage.html">GifImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw GIF images. Exif/IPTC metadata are supported directly.  <a href="classExiv2_1_1GifImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1NativePreview.html">NativePreview</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native preview information. This is meant to be used only by the <a class="el" href="classExiv2_1_1PreviewManager.html" title="Class for extracting preview images from image metadata. ">PreviewManager</a>.  <a href="structExiv2_1_1NativePreview.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class defining the interface for an image. This is the top-level interface to the <a class="el" href="namespaceExiv2.html" title="Provides classes and functions to encode and decode Exif and Iptc data. The libexiv2 API consists of ...">Exiv2</a> library.  <a href="classExiv2_1_1Image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ImageFactory.html">ImageFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classExiv2_1_1Image.html" title="Abstract base class defining the interface for an image. This is the top-level interface to the Exiv2...">Image</a> instance of the specified type.  <a href="classExiv2_1_1ImageFactory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Iptcdatum.html">Iptcdatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IPTC metadatum ("dataset"), consisting of an <a class="el" href="classExiv2_1_1IptcKey.html" title="Concrete keys for IPTC metadata. ">IptcKey</a> and a <a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> and methods to manipulate these.  <a href="classExiv2_1_1Iptcdatum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1IptcData.html">IptcData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for IPTC data. This is a top-level class of the Exiv2 library.  <a href="classExiv2_1_1IptcData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1IptcParser.html">IptcParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for IPTC data. Images use this class to decode and encode binary IPTC data.  <a href="classExiv2_1_1IptcParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Jp2Image.html">Jp2Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access JPEG-2000 images.  <a href="classExiv2_1_1Jp2Image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1Photoshop.html">Photoshop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class, has methods to deal with Photoshop "Information
       Resource Blocks" (IRBs).  <a href="structExiv2_1_1Photoshop.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1JpegBase.html">JpegBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract helper base class to access JPEG images.  <a href="classExiv2_1_1JpegBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1JpegImage.html">JpegImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access JPEG images.  <a href="classExiv2_1_1JpegImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExvImage.html">ExvImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to access Exiv2 files.  <a href="classExiv2_1_1ExvImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1MatroskaTags.html">MatroskaTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure for the Matroska tags lookup table.  <a href="structExiv2_1_1MatroskaTags.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1MatroskaVideo.html">MatroskaVideo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access Matroska video files.  <a href="classExiv2_1_1MatroskaVideo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Key.html">Key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class defining the Key of a metadatum. Keys are used to identify and group metadata.  <a href="classExiv2_1_1Key.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class defining the interface to access information related to one metadata tag.  <a href="classExiv2_1_1Metadatum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1MrwImage.html">MrwImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Minolta MRW images. Exif metadata is supported directly, IPTC is read from the Exif data, if present.  <a href="classExiv2_1_1MrwImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1OrfImage.html">OrfImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Olympus ORF images. Exif metadata is supported directly, IPTC is read from the Exif data, if present.  <a href="classExiv2_1_1OrfImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1OrfParser.html">OrfParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for data in ORF format. Images use this class to decode and encode ORF data. See class <a class="el" href="classExiv2_1_1TiffParser.html" title="Stateless parser class for data in TIFF format. Images use this class to decode and encode TIFF data...">TiffParser</a> for details.  <a href="classExiv2_1_1OrfParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1PgfImage.html">PgfImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access PGF images. Exif and IPTC metadata are supported directly.  <a href="classExiv2_1_1PgfImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1PngImage.html">PngImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access PNG images. Exif and IPTC metadata are supported directly.  <a href="classExiv2_1_1PngImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1PreviewProperties.html">PreviewProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preview image properties.  <a href="structExiv2_1_1PreviewProperties.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1PreviewImage.html">PreviewImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that holds preview image properties and data buffer.  <a href="classExiv2_1_1PreviewImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1PreviewManager.html">PreviewManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for extracting preview images from image metadata.  <a href="classExiv2_1_1PreviewManager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1XmpPropertyInfo.html">XmpPropertyInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about one XMP property.  <a href="structExiv2_1_1XmpPropertyInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1XmpNsInfo.html">XmpNsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure mapping XMP namespaces and (preferred) prefixes.  <a href="structExiv2_1_1XmpNsInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpProperties.html">XmpProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XMP property reference, implemented as a static class.  <a href="classExiv2_1_1XmpProperties.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpKey.html">XmpKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete keys for XMP metadata.  <a href="classExiv2_1_1XmpKey.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1PsdImage.html">PsdImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw <a class="el" href="structExiv2_1_1Photoshop.html" title="Helper class, has methods to deal with Photoshop &quot;Information        Resource Blocks&quot; (IRBs)...">Photoshop</a> images.  <a href="classExiv2_1_1PsdImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1QuickTimeVideo.html">QuickTimeVideo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access QuickTime video files.  <a href="classExiv2_1_1QuickTimeVideo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1RafImage.html">RafImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Fujifilm RAF images. Exif metadata is supported directly, IPTC is read from the Exif data, if present.  <a href="classExiv2_1_1RafImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1RiffVideo.html">RiffVideo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access RIFF video files.  <a href="classExiv2_1_1RiffVideo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Rw2Image.html">Rw2Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw Panasonic RW2 images. Exif metadata is supported directly, IPTC and XMP are read from the Exif data, if present.  <a href="classExiv2_1_1Rw2Image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Rw2Parser.html">Rw2Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for data in RW2 format. Images use this class to decode and encode RW2 data. Only decoding is currently implemented. See class <a class="el" href="classExiv2_1_1TiffParser.html" title="Stateless parser class for data in TIFF format. Images use this class to decode and encode TIFF data...">TiffParser</a> for details.  <a href="classExiv2_1_1Rw2Parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1SSH.html">SSH</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1GroupInfo.html">GroupInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The details of an Exif group. Groups include IFDs and binary arrays.  <a href="structExiv2_1_1GroupInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1TagInfo.html">TagInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag information.  <a href="structExiv2_1_1TagInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifTags.html">ExifTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to Exif group and tag lists and misc. tag reference methods, implemented as a static class.  <a href="classExiv2_1_1ExifTags.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ExifKey.html">ExifKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete keys for Exif metadata and access to Exif tag reference data.  <a href="classExiv2_1_1ExifKey.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1TgaImage.html">TgaImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access raw TARGA images. This is just a stub - we only read width and height.  <a href="classExiv2_1_1TgaImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1TiffImage.html">TiffImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access TIFF images. Exif metadata is supported directly, IPTC is read from the Exif data, if present.  <a href="classExiv2_1_1TiffImage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1TiffParser.html">TiffParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for data in TIFF format. Images use this class to decode and encode TIFF data. It is a wrapper of the internal class <a class="el" href="classExiv2_1_1Internal_1_1TiffParserWorker.html" title="Stateless parser class for data in TIFF format. Images use this class to decode and encode TIFF-based...">Internal::TiffParserWorker</a>.  <a href="classExiv2_1_1TiffParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1TypeInfo.html">TypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information lookup functions. Implemented as a static class.  <a href="classExiv2_1_1TypeInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExiv2_1_1DataBufRef.html">DataBufRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type to enable copies and assignments, similar to std::auto_ptr_ref. See <a href="http://www.josuttis.com/libbook/auto_ptr.html">http://www.josuttis.com/libbook/auto_ptr.html</a> for a discussion.  <a href="structExiv2_1_1DataBufRef.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1DataBuf.html">DataBuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class containing a character array. All it does is to take care of memory allocation and deletion. Its primary use is meant to be as a stack variable in functions that need a temporary data buffer.  <a href="classExiv2_1_1DataBuf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface for all types of values used with metadata.  <a href="classExiv2_1_1Value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1DataValue.html">DataValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for an undefined data type.  <a href="classExiv2_1_1DataValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1StringValueBase.html">StringValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for a string based Value type.  <a href="classExiv2_1_1StringValueBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1StringValue.html">StringValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for string type.  <a href="classExiv2_1_1StringValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1AsciiValue.html">AsciiValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for an Ascii string type.  <a href="classExiv2_1_1AsciiValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1CommentValue.html">CommentValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for an Exif comment.  <a href="classExiv2_1_1CommentValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpValue.html">XmpValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <a class="el" href="namespaceExiv2.html" title="Provides classes and functions to encode and decode Exif and Iptc data. The libexiv2 API consists of ...">Exiv2</a> values used to store XMP property values.  <a href="classExiv2_1_1XmpValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpTextValue.html">XmpTextValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type suitable for simple XMP properties and XMP nodes of complex types which are not parsed into specific values.  <a href="classExiv2_1_1XmpTextValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpArrayValue.html">XmpArrayValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for simple arrays. Each item in the array is a simple value, without qualifiers. The array may be an ordered (<em>seq</em>), unordered (<em>bag</em>) or alternative array (<em>alt</em>). The array items must not contain qualifiers. For language alternatives use <a class="el" href="classExiv2_1_1LangAltValue.html" title="Value type for XMP language alternative properties. ">LangAltValue</a>.  <a href="classExiv2_1_1XmpArrayValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1LangAltValue.html">LangAltValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for XMP language alternative properties.  <a href="classExiv2_1_1LangAltValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1DateValue.html">DateValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for simple ISO 8601 dates  <a href="classExiv2_1_1DateValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1TimeValue.html">TimeValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for simple ISO 8601 times.  <a href="classExiv2_1_1TimeValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1ValueType.html">ValueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals.  <a href="classExiv2_1_1ValueType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1Xmpdatum.html">Xmpdatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information related to an XMP property. An XMP metadatum consists of an <a class="el" href="classExiv2_1_1XmpKey.html" title="Concrete keys for XMP metadata. ">XmpKey</a> and a <a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> and provides methods to manipulate these.  <a href="classExiv2_1_1Xmpdatum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpData.html">XmpData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for XMP data. This is a top-level class of the Exiv2 library.  <a href="classExiv2_1_1XmpData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpParser.html">XmpParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless parser class for XMP packets. Images use this class to parse and serialize XMP packets. The parser uses the XMP toolkit to do the job.  <a href="classExiv2_1_1XmpParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExiv2_1_1XmpSidecar.html">XmpSidecar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to access XMP sidecar files. They contain only XMP metadata.  <a href="classExiv2_1_1XmpSidecar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:accd3e49cafe9db52c1e0e6f648753cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accd3e49cafe9db52c1e0e6f648753cae"></a>
typedef <a class="el" href="classExiv2_1_1BasicError.html">BasicError</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#accd3e49cafe9db52c1e0e6f648753cae">Error</a></td></tr>
<tr class="memdesc:accd3e49cafe9db52c1e0e6f648753cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error class used for exceptions (std::string based) <br/></td></tr>
<tr class="separator:accd3e49cafe9db52c1e0e6f648753cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a10b1ca722d594efdf5472464c8ba4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a10b1ca722d594efdf5472464c8ba4"></a>
typedef std::list&lt; <a class="el" href="classExiv2_1_1Exifdatum.html">Exifdatum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a93a10b1ca722d594efdf5472464c8ba4">ExifMetadata</a></td></tr>
<tr class="memdesc:a93a10b1ca722d594efdf5472464c8ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type to hold all metadata. <br/></td></tr>
<tr class="separator:a93a10b1ca722d594efdf5472464c8ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1981c551b955cd6a6cb0bfc08fbfef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1981c551b955cd6a6cb0bfc08fbfef8"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="namespaceExiv2.html#a26b6aada6dabfccfc0e99559feb91887">Protocol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>protDict_t</b></td></tr>
<tr class="separator:aa1981c551b955cd6a6cb0bfc08fbfef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58577e5d2687c17f9b8f03ead41abe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac58577e5d2687c17f9b8f03ead41abe6"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="namespaceExiv2.html#a26b6aada6dabfccfc0e99559feb91887">Protocol</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>protDict_i</b></td></tr>
<tr class="separator:ac58577e5d2687c17f9b8f03ead41abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49425a88ab1b00eb81d40601790a1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e49425a88ab1b00eb81d40601790a1e"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dict_t</b></td></tr>
<tr class="separator:a6e49425a88ab1b00eb81d40601790a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea14c391e9151be0d628b51842eb7c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea14c391e9151be0d628b51842eb7c5"></a>
typedef dict_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>dict_i</b></td></tr>
<tr class="separator:a9ea14c391e9151be0d628b51842eb7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72182be3e51f30ef8cb55a86dfa8e67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af72182be3e51f30ef8cb55a86dfa8e67"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structExiv2_1_1NativePreview.html">NativePreview</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af72182be3e51f30ef8cb55a86dfa8e67">NativePreviewList</a></td></tr>
<tr class="memdesc:af72182be3e51f30ef8cb55a86dfa8e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of native previews. This is meant to be used only by the <a class="el" href="classExiv2_1_1PreviewManager.html" title="Class for extracting preview images from image metadata. ">PreviewManager</a>. <br/></td></tr>
<tr class="separator:af72182be3e51f30ef8cb55a86dfa8e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac744f9ab24f7fd0fb9b46b156731aa5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac744f9ab24f7fd0fb9b46b156731aa5a"></a>
typedef <a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac744f9ab24f7fd0fb9b46b156731aa5a">NewInstanceFct</a> )(<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:ac744f9ab24f7fd0fb9b46b156731aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for function pointer that creates new <a class="el" href="classExiv2_1_1Image.html" title="Abstract base class defining the interface for an image. This is the top-level interface to the Exiv2...">Image</a> instances. <br/></td></tr>
<tr class="separator:ac744f9ab24f7fd0fb9b46b156731aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcc4a2285707a4efe2defe8806c3c67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdcc4a2285707a4efe2defe8806c3c67"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afdcc4a2285707a4efe2defe8806c3c67">IsThisTypeFct</a> )(<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:afdcc4a2285707a4efe2defe8806c3c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for function pointer that checks image types. <br/></td></tr>
<tr class="separator:afdcc4a2285707a4efe2defe8806c3c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caa9cbded318bf7d22a2d219c3d45f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5caa9cbded318bf7d22a2d219c3d45f4"></a>
typedef std::vector&lt; <a class="el" href="classExiv2_1_1Iptcdatum.html">Iptcdatum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5caa9cbded318bf7d22a2d219c3d45f4">IptcMetadata</a></td></tr>
<tr class="memdesc:a5caa9cbded318bf7d22a2d219c3d45f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type to hold all metadata. <br/></td></tr>
<tr class="separator:a5caa9cbded318bf7d22a2d219c3d45f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf3033d88acbcf7a808946868f0b239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf3033d88acbcf7a808946868f0b239"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a7cf3033d88acbcf7a808946868f0b239">PreviewId</a></td></tr>
<tr class="memdesc:a7cf3033d88acbcf7a808946868f0b239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of preview image. <br/></td></tr>
<tr class="separator:a7cf3033d88acbcf7a808946868f0b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46a7838fd620360c753a64922b0d559"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad46a7838fd620360c753a64922b0d559"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structExiv2_1_1PreviewProperties.html">PreviewProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ad46a7838fd620360c753a64922b0d559">PreviewPropertiesList</a></td></tr>
<tr class="memdesc:ad46a7838fd620360c753a64922b0d559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type to hold all preview images metadata. <br/></td></tr>
<tr class="separator:ad46a7838fd620360c753a64922b0d559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eab57168acb008b5974a414144e1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66eab57168acb008b5974a414144e1d2"></a>
typedef std::ostream &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a66eab57168acb008b5974a414144e1d2">PrintFct</a> )(std::ostream &amp;, const <a class="el" href="classExiv2_1_1Value.html">Value</a> &amp;, const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> *pExifData)</td></tr>
<tr class="memdesc:a66eab57168acb008b5974a414144e1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a function pointer for functions interpreting the tag value. <br/></td></tr>
<tr class="separator:a66eab57168acb008b5974a414144e1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e505a05c778aa26cddfc15078563e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41e505a05c778aa26cddfc15078563e7"></a>
typedef const <a class="el" href="structExiv2_1_1TagInfo.html">TagInfo</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a41e505a05c778aa26cddfc15078563e7">TagListFct</a> )()</td></tr>
<tr class="memdesc:a41e505a05c778aa26cddfc15078563e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning a tag list. <br/></td></tr>
<tr class="separator:a41e505a05c778aa26cddfc15078563e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f60a5bd4207fe155f6cf93a15efa72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16f60a5bd4207fe155f6cf93a15efa72"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a></td></tr>
<tr class="memdesc:a16f60a5bd4207fe155f6cf93a15efa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 byte unsigned integer type. <br/></td></tr>
<tr class="separator:a16f60a5bd4207fe155f6cf93a15efa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcaa9af0563cbd00a19b040d5aa7a70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedcaa9af0563cbd00a19b040d5aa7a70"></a>
typedef std::pair&lt; uint32_t, <br class="typebreak"/>
uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a></td></tr>
<tr class="memdesc:aedcaa9af0563cbd00a19b040d5aa7a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 byte unsigned rational type. <br/></td></tr>
<tr class="separator:aedcaa9af0563cbd00a19b040d5aa7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95756f3f7fa19103f83addf5fa088a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95756f3f7fa19103f83addf5fa088a30"></a>
typedef std::pair&lt; int32_t, <br class="typebreak"/>
int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a></td></tr>
<tr class="memdesc:a95756f3f7fa19103f83addf5fa088a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 byte signed rational type. <br/></td></tr>
<tr class="separator:a95756f3f7fa19103f83addf5fa088a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b9a2ef47caec919b15f1ae6ff4872"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e7b9a2ef47caec919b15f1ae6ff4872"></a>
typedef std::vector&lt; <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a6e7b9a2ef47caec919b15f1ae6ff4872">Blob</a></td></tr>
<tr class="memdesc:a6e7b9a2ef47caec919b15f1ae6ff4872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for binary data. <br/></td></tr>
<tr class="separator:a6e7b9a2ef47caec919b15f1ae6ff4872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f00bf58d6021c8c297f070d4a761651"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f00bf58d6021c8c297f070d4a761651"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a3f00bf58d6021c8c297f070d4a761651">UShortValue</a></td></tr>
<tr class="memdesc:a3f00bf58d6021c8c297f070d4a761651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short value type. <br/></td></tr>
<tr class="separator:a3f00bf58d6021c8c297f070d4a761651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25aa284d2da55e64eba4e8ed0692149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab25aa284d2da55e64eba4e8ed0692149"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ab25aa284d2da55e64eba4e8ed0692149">ULongValue</a></td></tr>
<tr class="memdesc:ab25aa284d2da55e64eba4e8ed0692149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned long value type. <br/></td></tr>
<tr class="separator:ab25aa284d2da55e64eba4e8ed0692149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f4de646ee869927f6246645b142626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16f4de646ee869927f6246645b142626"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; <a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a16f4de646ee869927f6246645b142626">URationalValue</a></td></tr>
<tr class="memdesc:a16f4de646ee869927f6246645b142626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned rational value type. <br/></td></tr>
<tr class="separator:a16f4de646ee869927f6246645b142626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67665147cbe2c7bd22af5aed7b7478ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67665147cbe2c7bd22af5aed7b7478ca"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a67665147cbe2c7bd22af5aed7b7478ca">ShortValue</a></td></tr>
<tr class="memdesc:a67665147cbe2c7bd22af5aed7b7478ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed short value type. <br/></td></tr>
<tr class="separator:a67665147cbe2c7bd22af5aed7b7478ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f8d64316779977c1869da776c26b6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47f8d64316779977c1869da776c26b6e"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a47f8d64316779977c1869da776c26b6e">LongValue</a></td></tr>
<tr class="memdesc:a47f8d64316779977c1869da776c26b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long value type. <br/></td></tr>
<tr class="separator:a47f8d64316779977c1869da776c26b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a69ae1200f28233d89237bcefe952f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2a69ae1200f28233d89237bcefe952f"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ab2a69ae1200f28233d89237bcefe952f">RationalValue</a></td></tr>
<tr class="memdesc:ab2a69ae1200f28233d89237bcefe952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed rational value type. <br/></td></tr>
<tr class="separator:ab2a69ae1200f28233d89237bcefe952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9260b475b138fdc65e6cba9c8c7b02a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9260b475b138fdc65e6cba9c8c7b02a3"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a9260b475b138fdc65e6cba9c8c7b02a3">FloatValue</a></td></tr>
<tr class="memdesc:a9260b475b138fdc65e6cba9c8c7b02a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float value type. <br/></td></tr>
<tr class="separator:a9260b475b138fdc65e6cba9c8c7b02a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc09286d7a62c49ef04cb66c0427518b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc09286d7a62c49ef04cb66c0427518b"></a>
typedef <a class="el" href="classExiv2_1_1ValueType.html">ValueType</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afc09286d7a62c49ef04cb66c0427518b">DoubleValue</a></td></tr>
<tr class="memdesc:afc09286d7a62c49ef04cb66c0427518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double value type. <br/></td></tr>
<tr class="separator:afc09286d7a62c49ef04cb66c0427518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef92d6c930cf939c01291a526e128677"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef92d6c930cf939c01291a526e128677"></a>
typedef std::vector&lt; <a class="el" href="classExiv2_1_1Xmpdatum.html">Xmpdatum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aef92d6c930cf939c01291a526e128677">XmpMetadata</a></td></tr>
<tr class="memdesc:aef92d6c930cf939c01291a526e128677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type to hold all metadata. <br/></td></tr>
<tr class="separator:aef92d6c930cf939c01291a526e128677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5dea113f005c36569d07fa669efcd782"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>EnVar</b> { <b>envHTTPPOST</b> = 0
 }</td></tr>
<tr class="separator:a5dea113f005c36569d07fa669efcd782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b6aada6dabfccfc0e99559feb91887"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a26b6aada6dabfccfc0e99559feb91887">Protocol</a> { <br/>
&#160;&#160;<b>pFile</b> = 0, 
<b>pHttp</b>, 
<b>pFtp</b>, 
<b>pHttps</b>, 
<br/>
&#160;&#160;<b>pSftp</b>, 
<b>pSsh</b>
<br/>
 }</td></tr>
<tr class="memdesc:a26b6aada6dabfccfc0e99559feb91887"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Protocol enum and the map to hold the strings. <br/></td></tr>
<tr class="separator:a26b6aada6dabfccfc0e99559feb91887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa280a04d28597f8259460e3d322a9489"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aa280a04d28597f8259460e3d322a9489">XmpCategory</a> { <b>xmpInternal</b>, 
<b>xmpExternal</b>
 }</td></tr>
<tr class="memdesc:aa280a04d28597f8259460e3d322a9489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category of an XMP property. <br/></td></tr>
<tr class="separator:aa280a04d28597f8259460e3d322a9489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c225faf6d6c611a3828fae1c28efa6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> { <b>invalidByteOrder</b>, 
<b>littleEndian</b>, 
<b>bigEndian</b>, 
<b>asciiBytes</b>
 }</td></tr>
<tr class="memdesc:a94c225faf6d6c611a3828fae1c28efa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to express the byte order (little or big endian) <br/></td></tr>
<tr class="separator:a94c225faf6d6c611a3828fae1c28efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfd4f86ce5d686323498c42cfd6cde7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aabfd4f86ce5d686323498c42cfd6cde7">WriteMethod</a> { <b>wmIntrusive</b>, 
<b>wmNonIntrusive</b>
 }</td></tr>
<tr class="memdesc:aabfd4f86ce5d686323498c42cfd6cde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to indicate write method used by TIFF parsers. <br/></td></tr>
<tr class="separator:aabfd4f86ce5d686323498c42cfd6cde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca494c8cf80f3ac8a804e1b54afffca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#acca494c8cf80f3ac8a804e1b54afffca">MetadataId</a> { <br/>
&#160;&#160;<b>mdNone</b> =0, 
<b>mdExif</b> =1, 
<b>mdIptc</b> =2, 
<b>mdComment</b> =4, 
<br/>
&#160;&#160;<b>mdXmp</b> =8
<br/>
 }</td></tr>
<tr class="memdesc:acca494c8cf80f3ac8a804e1b54afffca"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identifier for each type of metadata. <br/></td></tr>
<tr class="separator:acca494c8cf80f3ac8a804e1b54afffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f0ea6c944c786f7c4c4841fa22b16c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af5f0ea6c944c786f7c4c4841fa22b16c">AccessMode</a> { <b>amNone</b> =0, 
<b>amRead</b> =1, 
<b>amWrite</b> =2, 
<b>amReadWrite</b> =3
 }</td></tr>
<tr class="memdesc:af5f0ea6c944c786f7c4c4841fa22b16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identifier for each mode of metadata support. <br/></td></tr>
<tr class="separator:af5f0ea6c944c786f7c4c4841fa22b16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5153319711f35fe81cbc13f4b852450c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a> { <br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca6abd8e6e48dddae9bac03019ae907795">unsignedByte</a> = 1, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca773cf6dde5caaabb3dcf9fb161fa7dfd">asciiString</a> = 2, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca0329efdda8becff3ecf89bfbc816f72c">unsignedShort</a> = 3, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca3b506c0729276e4de3a0ab4d9b2226bd">unsignedLong</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450cae450f64413c928b527cfdd73129d6606">unsignedRational</a> = 5, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca717f7d50dd484167359361d2c560f83c">signedByte</a> = 6, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450caa044ece6f004f519dce91f57319bb6eb">undefined</a> = 7, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca4a46f8aa5e64d33468602515f6255b65">signedShort</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca501fdf1b61472bff3b4da19b956eabda">signedLong</a> = 9, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca0d777a3a2542fbff07ed29563167b3b5">signedRational</a> =10, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450cabcc0eb22efc41f32ba573c18731b4928">tiffFloat</a> =11, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca9b4d2fa208df5c86d24f7d7c41bd09a2">tiffDouble</a> =12, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450cae9896f64a72a68e176f02c1880b19681">tiffIfd</a> =13, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca2d79fb07c9ec891f281968dad43c1e25">string</a> =0x10000, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca0c347d8ddbbad9440f9bb6db8a06fa45">date</a> =0x10001, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca8526caf002a100bd730312d45808f1b6">time</a> =0x10002, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca98944819f3c9921109af5f0a39fcfa34">comment</a> =0x10003, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450cafc7cbf89ae7c64de808dc3611b2a880f">directory</a> =0x10004, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca77cea60f60ef2c6f0f986137c5404c02">xmpText</a> =0x10005, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca627dda12626324231bb87883d8efc5df">xmpAlt</a> =0x10006, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450caa5e7700549d4b079db70605d945447af">xmpBag</a> =0x10007, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca969c20e44455272599e3a273471546e8">xmpSeq</a> =0x10008, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca52dce1d022dd8927bc651d2e51dc1bcd">langAlt</a> =0x10009, 
<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450cafc75de7290b703a810102c8a003fc25e">invalidTypeId</a> =0x1fffe, 
<br/>
&#160;&#160;<a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca1d087498b678aa18f77ab6b5c1812921">lastTypeId</a> =0x1ffff
<br/>
 }</td></tr>
<tr class="memdesc:a5153319711f35fe81cbc13f4b852450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exiv2 value type identifiers.  <a href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">More...</a><br/></td></tr>
<tr class="separator:a5153319711f35fe81cbc13f4b852450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11290f0338e59bd5b96da1870e493c5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11290f0338e59bd5b96da1870e493c5c"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a11290f0338e59bd5b96da1870e493c5c">newAsfInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a11290f0338e59bd5b96da1870e493c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1AsfVideo.html" title="Class to access ASF video files. ">AsfVideo</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a11290f0338e59bd5b96da1870e493c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6344a9183a9acb24b8c2bcf44fad8228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6344a9183a9acb24b8c2bcf44fad8228"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a6344a9183a9acb24b8c2bcf44fad8228">isAsfType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a6344a9183a9acb24b8c2bcf44fad8228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Windows Asf Video. <br/></td></tr>
<tr class="separator:a6344a9183a9acb24b8c2bcf44fad8228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c87ddedd63e9ab9aa6f295cda32aebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExiv2_1_1DataBuf.html">DataBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5c87ddedd63e9ab9aa6f295cda32aebd">readFile</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a5c87ddedd63e9ab9aa6f295cda32aebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read file <em>path</em> into a <a class="el" href="classExiv2_1_1DataBuf.html" title="Utility class containing a character array. All it does is to take care of memory allocation and dele...">DataBuf</a>, which is returned.  <a href="#a5c87ddedd63e9ab9aa6f295cda32aebd">More...</a><br/></td></tr>
<tr class="separator:a5c87ddedd63e9ab9aa6f295cda32aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c0189894e7563da9a932e9c826e761"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a65c0189894e7563da9a932e9c826e761">writeFile</a> (const <a class="el" href="classExiv2_1_1DataBuf.html">DataBuf</a> &amp;buf, const std::string &amp;path)</td></tr>
<tr class="memdesc:a65c0189894e7563da9a932e9c826e761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <a class="el" href="classExiv2_1_1DataBuf.html" title="Utility class containing a character array. All it does is to take care of memory allocation and dele...">DataBuf</a> <em>buf</em> to file <em>path</em>.  <a href="#a65c0189894e7563da9a932e9c826e761">More...</a><br/></td></tr>
<tr class="separator:a65c0189894e7563da9a932e9c826e761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548778abb2cec5c7cfc18d38355c0a0f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a548778abb2cec5c7cfc18d38355c0a0f">ReplaceStringInPlace</a> (std::string subject, const std::string &amp;search, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a548778abb2cec5c7cfc18d38355c0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace each substring of the subject that matches the given search string with the given replacement.  <a href="#a548778abb2cec5c7cfc18d38355c0a0f">More...</a><br/></td></tr>
<tr class="separator:a548778abb2cec5c7cfc18d38355c0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cb5f6b3d4cf6c6353bf756993dad5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6cb5f6b3d4cf6c6353bf756993dad5b"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac6cb5f6b3d4cf6c6353bf756993dad5b">newBmpInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:ac6cb5f6b3d4cf6c6353bf756993dad5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1BmpImage.html" title="Class to access Windows bitmaps. This is just a stub - we only read width and height. ">BmpImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:ac6cb5f6b3d4cf6c6353bf756993dad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b3160e1cdce93c1f30c7717d04a4da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b3160e1cdce93c1f30c7717d04a4da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a82b3160e1cdce93c1f30c7717d04a4da">isBmpType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a82b3160e1cdce93c1f30c7717d04a4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Windows Bitmap image. <br/></td></tr>
<tr class="separator:a82b3160e1cdce93c1f30c7717d04a4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4194fe13abc45d8b938e0c53eae1ae0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4194fe13abc45d8b938e0c53eae1ae0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4194fe13abc45d8b938e0c53eae1ae0e">copyExifToXmp</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;exifData, <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData)</td></tr>
<tr class="memdesc:a4194fe13abc45d8b938e0c53eae1ae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (copy) Exif tags to XMP properties. <br/></td></tr>
<tr class="separator:a4194fe13abc45d8b938e0c53eae1ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af299945c10261453f13fc9978dc65f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af299945c10261453f13fc9978dc65f9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af299945c10261453f13fc9978dc65f9f">moveExifToXmp</a> (<a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;exifData, <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData)</td></tr>
<tr class="memdesc:af299945c10261453f13fc9978dc65f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (move) Exif tags to XMP properties, remove converted Exif tags. <br/></td></tr>
<tr class="separator:af299945c10261453f13fc9978dc65f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa3a7c410d59611dd8aa929aae0c71b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa3a7c410d59611dd8aa929aae0c71b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a3aa3a7c410d59611dd8aa929aae0c71b">copyXmpToExif</a> (const <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;exifData)</td></tr>
<tr class="memdesc:a3aa3a7c410d59611dd8aa929aae0c71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (copy) XMP properties to Exif tags. <br/></td></tr>
<tr class="separator:a3aa3a7c410d59611dd8aa929aae0c71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2821575e2fa7ec58e22af507ea64ce58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2821575e2fa7ec58e22af507ea64ce58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2821575e2fa7ec58e22af507ea64ce58">moveXmpToExif</a> (<a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;exifData)</td></tr>
<tr class="memdesc:a2821575e2fa7ec58e22af507ea64ce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (move) XMP properties to Exif tags, remove converted XMP properties. <br/></td></tr>
<tr class="separator:a2821575e2fa7ec58e22af507ea64ce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e13fe5c81e44fddbffb3d47baeb23a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e13fe5c81e44fddbffb3d47baeb23a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af6e13fe5c81e44fddbffb3d47baeb23a">syncExifWithXmp</a> (<a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;exifData, <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData)</td></tr>
<tr class="memdesc:af6e13fe5c81e44fddbffb3d47baeb23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect which metadata are newer and perform a copy in appropriate direction. <br/></td></tr>
<tr class="separator:af6e13fe5c81e44fddbffb3d47baeb23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1037a2e2a1e4d75ba7456945d7fa417d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1037a2e2a1e4d75ba7456945d7fa417d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1037a2e2a1e4d75ba7456945d7fa417d">copyIptcToXmp</a> (const <a class="el" href="classExiv2_1_1IptcData.html">IptcData</a> &amp;iptcData, <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, const char *iptcCharset=0)</td></tr>
<tr class="memdesc:a1037a2e2a1e4d75ba7456945d7fa417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (copy) IPTC datasets to XMP properties. <br/></td></tr>
<tr class="separator:a1037a2e2a1e4d75ba7456945d7fa417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37063afa8fa710d4c2ad6d266f5230d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab37063afa8fa710d4c2ad6d266f5230d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ab37063afa8fa710d4c2ad6d266f5230d">moveIptcToXmp</a> (<a class="el" href="classExiv2_1_1IptcData.html">IptcData</a> &amp;iptcData, <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, const char *iptcCharset=0)</td></tr>
<tr class="memdesc:ab37063afa8fa710d4c2ad6d266f5230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (move) IPTC datasets to XMP properties, remove converted IPTC datasets. <br/></td></tr>
<tr class="separator:ab37063afa8fa710d4c2ad6d266f5230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec16e78c8f6184811c8b031abd0b8e74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec16e78c8f6184811c8b031abd0b8e74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aec16e78c8f6184811c8b031abd0b8e74">copyXmpToIptc</a> (const <a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, <a class="el" href="classExiv2_1_1IptcData.html">IptcData</a> &amp;iptcData)</td></tr>
<tr class="memdesc:aec16e78c8f6184811c8b031abd0b8e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (copy) XMP properties to IPTC datasets. <br/></td></tr>
<tr class="separator:aec16e78c8f6184811c8b031abd0b8e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add907b8334920b392291afc75f921546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add907b8334920b392291afc75f921546"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#add907b8334920b392291afc75f921546">moveXmpToIptc</a> (<a class="el" href="classExiv2_1_1XmpData.html">XmpData</a> &amp;xmpData, <a class="el" href="classExiv2_1_1IptcData.html">IptcData</a> &amp;iptcData)</td></tr>
<tr class="memdesc:add907b8334920b392291afc75f921546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (move) XMP properties to IPTC tags, remove converted XMP properties. <br/></td></tr>
<tr class="separator:add907b8334920b392291afc75f921546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa666fe01fbcfa969b3e2c648bcf9ae8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aaa666fe01fbcfa969b3e2c648bcf9ae8">convertStringCharset</a> (std::string &amp;str, const char *from, const char *to)</td></tr>
<tr class="memdesc:aaa666fe01fbcfa969b3e2c648bcf9ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert character encoding of <em>str</em> from <em>from</em> to <em>to</em>. If the function succeeds, <em>str</em> contains the result string.  <a href="#aaa666fe01fbcfa969b3e2c648bcf9ae8">More...</a><br/></td></tr>
<tr class="separator:aaa666fe01fbcfa969b3e2c648bcf9ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd05a6d1d7b2db79c38d159b4d6c67a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd05a6d1d7b2db79c38d159b4d6c67a6"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afd05a6d1d7b2db79c38d159b4d6c67a6">newCr2Instance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:afd05a6d1d7b2db79c38d159b4d6c67a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1Cr2Image.html" title="Class to access raw Canon CR2 images. Exif metadata is supported directly, IPTC is read from the Exif...">Cr2Image</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:afd05a6d1d7b2db79c38d159b4d6c67a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9762d2176964085e569e969c282cdda9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9762d2176964085e569e969c282cdda9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a9762d2176964085e569e969c282cdda9">isCr2Type</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a9762d2176964085e569e969c282cdda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a CR2 image. <br/></td></tr>
<tr class="separator:a9762d2176964085e569e969c282cdda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee37e251aa0717d1cb8671ff446c705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abee37e251aa0717d1cb8671ff446c705"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abee37e251aa0717d1cb8671ff446c705">newCrwInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:abee37e251aa0717d1cb8671ff446c705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1CrwImage.html" title="Class to access raw Canon CRW images. Only Exif metadata and a comment are supported. CRW format does not contain IPTC metadata. ">CrwImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:abee37e251aa0717d1cb8671ff446c705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ae59b54c2052cc1bc6e08880fec280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72ae59b54c2052cc1bc6e08880fec280"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a72ae59b54c2052cc1bc6e08880fec280">isCrwType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a72ae59b54c2052cc1bc6e08880fec280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a CRW image. <br/></td></tr>
<tr class="separator:a72ae59b54c2052cc1bc6e08880fec280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8603ccd9a3e9a0ccac6662d363b9ed1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8603ccd9a3e9a0ccac6662d363b9ed1f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8603ccd9a3e9a0ccac6662d363b9ed1f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structExiv2_1_1DataSet.html">DataSet</a> &amp;dataSet)</td></tr>
<tr class="memdesc:a8603ccd9a3e9a0ccac6662d363b9ed1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for dataSet. <br/></td></tr>
<tr class="separator:a8603ccd9a3e9a0ccac6662d363b9ed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade21436d5ab749937db1de309a880cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade21436d5ab749937db1de309a880cf3"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ade21436d5ab749937db1de309a880cf3">orientation</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:ade21436d5ab749937db1de309a880cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation of the image. <br/></td></tr>
<tr class="separator:ade21436d5ab749937db1de309a880cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d233d6897570fcd74607c1b545f0039"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d233d6897570fcd74607c1b545f0039"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8d233d6897570fcd74607c1b545f0039">isoSpeed</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a8d233d6897570fcd74607c1b545f0039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ISO speed used to shoot the image. <br/></td></tr>
<tr class="separator:a8d233d6897570fcd74607c1b545f0039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a59a35dd77f48149f56c8cb4385ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab39a59a35dd77f48149f56c8cb4385ba"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ab39a59a35dd77f48149f56c8cb4385ba">flashBias</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:ab39a59a35dd77f48149f56c8cb4385ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flash bias value. <br/></td></tr>
<tr class="separator:ab39a59a35dd77f48149f56c8cb4385ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c527d75a6c5d9c2efa9a20e6f60ef4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9c527d75a6c5d9c2efa9a20e6f60ef4"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aa9c527d75a6c5d9c2efa9a20e6f60ef4">exposureMode</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:aa9c527d75a6c5d9c2efa9a20e6f60ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exposure mode setting. <br/></td></tr>
<tr class="separator:aa9c527d75a6c5d9c2efa9a20e6f60ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75576b2200b04d726018200257e835"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa75576b2200b04d726018200257e835"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afa75576b2200b04d726018200257e835">sceneMode</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:afa75576b2200b04d726018200257e835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scene mode setting. <br/></td></tr>
<tr class="separator:afa75576b2200b04d726018200257e835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91ad8038bef1a6d94413c6820396a56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91ad8038bef1a6d94413c6820396a56"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af91ad8038bef1a6d94413c6820396a56">macroMode</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:af91ad8038bef1a6d94413c6820396a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the macro mode setting. <br/></td></tr>
<tr class="separator:af91ad8038bef1a6d94413c6820396a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e478a9d6f92c9fc33c8e1fdc050230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14e478a9d6f92c9fc33c8e1fdc050230"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a14e478a9d6f92c9fc33c8e1fdc050230">imageQuality</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a14e478a9d6f92c9fc33c8e1fdc050230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the image quality setting. <br/></td></tr>
<tr class="separator:a14e478a9d6f92c9fc33c8e1fdc050230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e73621e478d4520fdcf601a1e10593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e73621e478d4520fdcf601a1e10593"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a13e73621e478d4520fdcf601a1e10593">whiteBalance</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a13e73621e478d4520fdcf601a1e10593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the white balance setting. <br/></td></tr>
<tr class="separator:a13e73621e478d4520fdcf601a1e10593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00abed868b1cd46fdeb8ab331af246cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00abed868b1cd46fdeb8ab331af246cd"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a00abed868b1cd46fdeb8ab331af246cd">lensName</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a00abed868b1cd46fdeb8ab331af246cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the lens used. <br/></td></tr>
<tr class="separator:a00abed868b1cd46fdeb8ab331af246cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a3451abf49f4f893ed25a70d958117"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63a3451abf49f4f893ed25a70d958117"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a63a3451abf49f4f893ed25a70d958117">saturation</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a63a3451abf49f4f893ed25a70d958117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the saturation level. <br/></td></tr>
<tr class="separator:a63a3451abf49f4f893ed25a70d958117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05ea2a3dea415b5cc2cd64133890947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac05ea2a3dea415b5cc2cd64133890947"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac05ea2a3dea415b5cc2cd64133890947">sharpness</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:ac05ea2a3dea415b5cc2cd64133890947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sharpness level. <br/></td></tr>
<tr class="separator:ac05ea2a3dea415b5cc2cd64133890947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5b5cc3546863a59f0bc5ec2ad6890d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e5b5cc3546863a59f0bc5ec2ad6890d"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a9e5b5cc3546863a59f0bc5ec2ad6890d">contrast</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a9e5b5cc3546863a59f0bc5ec2ad6890d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contrast level. <br/></td></tr>
<tr class="separator:a9e5b5cc3546863a59f0bc5ec2ad6890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a970a54be9984c7c081fb3b4cb169"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a155a970a54be9984c7c081fb3b4cb169"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a155a970a54be9984c7c081fb3b4cb169">sceneCaptureType</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a155a970a54be9984c7c081fb3b4cb169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scene capture type. <br/></td></tr>
<tr class="separator:a155a970a54be9984c7c081fb3b4cb169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c515ec0b9856491c76690282a3b9153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c515ec0b9856491c76690282a3b9153"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2c515ec0b9856491c76690282a3b9153">meteringMode</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a2c515ec0b9856491c76690282a3b9153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the metering mode setting. <br/></td></tr>
<tr class="separator:a2c515ec0b9856491c76690282a3b9153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3729578ba37d5e96f1aca75e9b9c0570"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3729578ba37d5e96f1aca75e9b9c0570"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a3729578ba37d5e96f1aca75e9b9c0570">make</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a3729578ba37d5e96f1aca75e9b9c0570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the camera make. <br/></td></tr>
<tr class="separator:a3729578ba37d5e96f1aca75e9b9c0570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f59ed4d80ac644965de6e550c2fe52d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f59ed4d80ac644965de6e550c2fe52d"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2f59ed4d80ac644965de6e550c2fe52d">model</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a2f59ed4d80ac644965de6e550c2fe52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the camera model. <br/></td></tr>
<tr class="separator:a2f59ed4d80ac644965de6e550c2fe52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e474d2eeb791247de17719fc34554c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e474d2eeb791247de17719fc34554c"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac7e474d2eeb791247de17719fc34554c">exposureTime</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:ac7e474d2eeb791247de17719fc34554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exposure time. <br/></td></tr>
<tr class="separator:ac7e474d2eeb791247de17719fc34554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e9152260bbca556dc85306eb2edffe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e9152260bbca556dc85306eb2edffe"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a56e9152260bbca556dc85306eb2edffe">fNumber</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a56e9152260bbca556dc85306eb2edffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the F number. <br/></td></tr>
<tr class="separator:a56e9152260bbca556dc85306eb2edffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1983a22f694ee672968665fa7e4a24ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1983a22f694ee672968665fa7e4a24ce"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1983a22f694ee672968665fa7e4a24ce">subjectDistance</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a1983a22f694ee672968665fa7e4a24ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the subject distance. <br/></td></tr>
<tr class="separator:a1983a22f694ee672968665fa7e4a24ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73382f42b15c8b22c34284a517a8f3b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73382f42b15c8b22c34284a517a8f3b5"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a73382f42b15c8b22c34284a517a8f3b5">serialNumber</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a73382f42b15c8b22c34284a517a8f3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the camera serial number. <br/></td></tr>
<tr class="separator:a73382f42b15c8b22c34284a517a8f3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7758be6d5c4a9a3d8d1cd784d3d0660"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7758be6d5c4a9a3d8d1cd784d3d0660"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af7758be6d5c4a9a3d8d1cd784d3d0660">focalLength</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:af7758be6d5c4a9a3d8d1cd784d3d0660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the focal length setting. <br/></td></tr>
<tr class="separator:af7758be6d5c4a9a3d8d1cd784d3d0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0617f292cafcfb4c9c2d1d63b7fd7b85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0617f292cafcfb4c9c2d1d63b7fd7b85"></a>
<a class="el" href="classExiv2_1_1ExifData.html#a2b8ac7a474d6527c0f3f6a0a9cebef77">ExifData::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a0617f292cafcfb4c9c2d1d63b7fd7b85">afPoint</a> (const <a class="el" href="classExiv2_1_1ExifData.html">ExifData</a> &amp;ed)</td></tr>
<tr class="memdesc:a0617f292cafcfb4c9c2d1d63b7fd7b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AF point. <br/></td></tr>
<tr class="separator:a0617f292cafcfb4c9c2d1d63b7fd7b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c888a872783b52be5d48a32e9cffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062c888a872783b52be5d48a32e9cffb"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a062c888a872783b52be5d48a32e9cffb">newEpsInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a062c888a872783b52be5d48a32e9cffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1EpsImage.html" title="Class to access EPS images. ">EpsImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a062c888a872783b52be5d48a32e9cffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee22daaeaeae27429093f977fe8258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ee22daaeaeae27429093f977fe8258"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a97ee22daaeaeae27429093f977fe8258">isEpsType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a97ee22daaeaeae27429093f977fe8258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a EPS image. <br/></td></tr>
<tr class="separator:a97ee22daaeaeae27429093f977fe8258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac628011b2304dd3c6fa65e7b52051"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ac628011b2304dd3c6fa65e7b52051"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a91ac628011b2304dd3c6fa65e7b52051">errMsg</a> (int code)</td></tr>
<tr class="memdesc:a91ac628011b2304dd3c6fa65e7b52051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error message for the error with code <em>code</em>. <br/></td></tr>
<tr class="separator:a91ac628011b2304dd3c6fa65e7b52051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1576dd000687193c9ebbb672eb7164"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f1576dd000687193c9ebbb672eb7164"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classExiv2_1_1Exifdatum.html">Exiv2::Exifdatum</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5f1576dd000687193c9ebbb672eb7164">setValue</a> (<a class="el" href="classExiv2_1_1Exifdatum.html">Exiv2::Exifdatum</a> &amp;exifDatum, const T &amp;value)</td></tr>
<tr class="memdesc:a5f1576dd000687193c9ebbb672eb7164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of <em>exifDatum</em> to <em>value</em>. If the object already has a value, it is replaced. Otherwise a new <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a>&lt;T&gt; value is created and set to <em>value</em>.  <a href="#a5f1576dd000687193c9ebbb672eb7164">More...</a><br/></td></tr>
<tr class="separator:a5f1576dd000687193c9ebbb672eb7164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120377a9321829303af20169373617b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120377a9321829303af20169373617b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getEnv</b> (EnVar var)</td></tr>
<tr class="separator:a120377a9321829303af20169373617b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568823b247fbbe5562c122bc8bf25156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568823b247fbbe5562c122bc8bf25156"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>to_hex</b> (char code)</td></tr>
<tr class="separator:a568823b247fbbe5562c122bc8bf25156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a34cdc631a15420e8d921f4faf820d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a34cdc631a15420e8d921f4faf820d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>from_hex</b> (char ch)</td></tr>
<tr class="separator:ab7a34cdc631a15420e8d921f4faf820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939835d09a7575fbfdeef64adff3a34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3939835d09a7575fbfdeef64adff3a34"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>urlencode</b> (char *str)</td></tr>
<tr class="separator:a3939835d09a7575fbfdeef64adff3a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00585168a5695e990e4240a80db77c7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00585168a5695e990e4240a80db77c7e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>urldecode</b> (const char *str)</td></tr>
<tr class="separator:a00585168a5695e990e4240a80db77c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c00f4c281884b7e6adcb32fbf6789b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a41c00f4c281884b7e6adcb32fbf6789b">base64encode</a> (const void *data_buf, size_t dataLength, char *result, size_t resultSize)</td></tr>
<tr class="memdesc:a41c00f4c281884b7e6adcb32fbf6789b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes in base64 the data in data_buf and puts the resulting string in result.  <a href="#a41c00f4c281884b7e6adcb32fbf6789b">More...</a><br/></td></tr>
<tr class="separator:a41c00f4c281884b7e6adcb32fbf6789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fafba026ab8971599f2c2dc7bb4072f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a26b6aada6dabfccfc0e99559feb91887">Protocol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8fafba026ab8971599f2c2dc7bb4072f">fileProtocol</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8fafba026ab8971599f2c2dc7bb4072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the protocol of the path.  <a href="#a8fafba026ab8971599f2c2dc7bb4072f">More...</a><br/></td></tr>
<tr class="separator:a8fafba026ab8971599f2c2dc7bb4072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0432df7d3995fa4d2fbc0b3f90265c59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a0432df7d3995fa4d2fbc0b3f90265c59">fileExists</a> (const std::string &amp;path, bool ct=false)</td></tr>
<tr class="memdesc:a0432df7d3995fa4d2fbc0b3f90265c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a file exists.  <a href="#a0432df7d3995fa4d2fbc0b3f90265c59">More...</a><br/></td></tr>
<tr class="separator:a0432df7d3995fa4d2fbc0b3f90265c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086796c27d01f4618a158a0e56905f72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a086796c27d01f4618a158a0e56905f72"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a086796c27d01f4618a158a0e56905f72">strError</a> ()</td></tr>
<tr class="memdesc:a086796c27d01f4618a158a0e56905f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system error message and the error code (errno). See strerror(3). <br/></td></tr>
<tr class="separator:a086796c27d01f4618a158a0e56905f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34934ab2ebed29730808fcccc6749765"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34934ab2ebed29730808fcccc6749765"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a34934ab2ebed29730808fcccc6749765">newGifInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a34934ab2ebed29730808fcccc6749765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1GifImage.html" title="Class to access raw GIF images. Exif/IPTC metadata are supported directly. ">GifImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a34934ab2ebed29730808fcccc6749765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8b0eceeb28acf1bc2a78b18acbfc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2b8b0eceeb28acf1bc2a78b18acbfc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae2b8b0eceeb28acf1bc2a78b18acbfc4">isGifType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:ae2b8b0eceeb28acf1bc2a78b18acbfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a GIF image. <br/></td></tr>
<tr class="separator:ae2b8b0eceeb28acf1bc2a78b18acbfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a4bb844932a834dd109ce2554a2a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717a4bb844932a834dd109ce2554a2a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a717a4bb844932a834dd109ce2554a2a4">append</a> (<a class="el" href="namespaceExiv2.html#a6e7b9a2ef47caec919b15f1ae6ff4872">Exiv2::Blob</a> &amp;blob, const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, uint32_t len)</td></tr>
<tr class="memdesc:a717a4bb844932a834dd109ce2554a2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <em>len</em> bytes pointed to by <em>buf</em> to <em>blob</em>. <br/></td></tr>
<tr class="separator:a717a4bb844932a834dd109ce2554a2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b52d6f278c7d098731d0a1d7aa4296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a17b52d6f278c7d098731d0a1d7aa4296">cmpIptcdataByRecord</a> (const <a class="el" href="classExiv2_1_1Iptcdatum.html">Iptcdatum</a> &amp;lhs, const <a class="el" href="classExiv2_1_1Iptcdatum.html">Iptcdatum</a> &amp;rhs)</td></tr>
<tr class="memdesc:a17b52d6f278c7d098731d0a1d7aa4296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iptc items by record. Return true if the record of lhs is less than that of rhs.  <a href="#a17b52d6f278c7d098731d0a1d7aa4296">More...</a><br/></td></tr>
<tr class="separator:a17b52d6f278c7d098731d0a1d7aa4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006be3869186bf1447fa475bdb98f8b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a006be3869186bf1447fa475bdb98f8b3"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a006be3869186bf1447fa475bdb98f8b3">newJp2Instance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a006be3869186bf1447fa475bdb98f8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1Jp2Image.html" title="Class to access JPEG-2000 images. ">Jp2Image</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a006be3869186bf1447fa475bdb98f8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1061485827f94c46921d3e1ceda8ba29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1061485827f94c46921d3e1ceda8ba29"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1061485827f94c46921d3e1ceda8ba29">isJp2Type</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a1061485827f94c46921d3e1ceda8ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a JPEG-2000 image. <br/></td></tr>
<tr class="separator:a1061485827f94c46921d3e1ceda8ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e504de88a8ce92e13f435aefce7f64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9e504de88a8ce92e13f435aefce7f64"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac9e504de88a8ce92e13f435aefce7f64">newJpegInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:ac9e504de88a8ce92e13f435aefce7f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1JpegImage.html" title="Class to access JPEG images. ">JpegImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:ac9e504de88a8ce92e13f435aefce7f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d7543e864557d19e67b91bb1843962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79d7543e864557d19e67b91bb1843962"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a79d7543e864557d19e67b91bb1843962">isJpegType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a79d7543e864557d19e67b91bb1843962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a JPEG image. <br/></td></tr>
<tr class="separator:a79d7543e864557d19e67b91bb1843962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06d892514a860aa84329826395835af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac06d892514a860aa84329826395835af"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac06d892514a860aa84329826395835af">newExvInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:ac06d892514a860aa84329826395835af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1ExvImage.html" title="Helper class to access Exiv2 files. ">ExvImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:ac06d892514a860aa84329826395835af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d08d5f85e7ce057e6ac5c0e5d1d95a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0d08d5f85e7ce057e6ac5c0e5d1d95a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae0d08d5f85e7ce057e6ac5c0e5d1d95a">isExvType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:ae0d08d5f85e7ce057e6ac5c0e5d1d95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is an EXV file. <br/></td></tr>
<tr class="separator:ae0d08d5f85e7ce057e6ac5c0e5d1d95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9885cab607b137052dbb18dbebe2e6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9885cab607b137052dbb18dbebe2e6e"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac9885cab607b137052dbb18dbebe2e6e">newMkvInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:ac9885cab607b137052dbb18dbebe2e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1MatroskaVideo.html" title="Class to access Matroska video files. ">MatroskaVideo</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:ac9885cab607b137052dbb18dbebe2e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9acb098a113c94f4f7f02f930aadca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9acb098a113c94f4f7f02f930aadca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aeb9acb098a113c94f4f7f02f930aadca">isMkvType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:aeb9acb098a113c94f4f7f02f930aadca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Matroska Video. <br/></td></tr>
<tr class="separator:aeb9acb098a113c94f4f7f02f930aadca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe183940aa386c68b9bb269f3f69b352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe183940aa386c68b9bb269f3f69b352"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afe183940aa386c68b9bb269f3f69b352">cmpMetadataByTag</a> (const <a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a> &amp;lhs, const <a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a> &amp;rhs)</td></tr>
<tr class="memdesc:afe183940aa386c68b9bb269f3f69b352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two metadata by tag. Return true if the tag of metadatum lhs is less than that of rhs. <br/></td></tr>
<tr class="separator:afe183940aa386c68b9bb269f3f69b352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a6b7174667cb72370cc0a52ad7004d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a6b7174667cb72370cc0a52ad7004d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ab6a6b7174667cb72370cc0a52ad7004d">cmpMetadataByKey</a> (const <a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a> &amp;lhs, const <a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a> &amp;rhs)</td></tr>
<tr class="memdesc:ab6a6b7174667cb72370cc0a52ad7004d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two metadata by key. Return true if the key of metadatum lhs is less than that of rhs. <br/></td></tr>
<tr class="separator:ab6a6b7174667cb72370cc0a52ad7004d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb3a02cde292ce110f77ffdc692c0ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb3a02cde292ce110f77ffdc692c0ee"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1bb3a02cde292ce110f77ffdc692c0ee">newMrwInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a1bb3a02cde292ce110f77ffdc692c0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1MrwImage.html" title="Class to access raw Minolta MRW images. Exif metadata is supported directly, IPTC is read from the Ex...">MrwImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a1bb3a02cde292ce110f77ffdc692c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bd48d4c5759f607e7ddaa7a7ce3d3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49bd48d4c5759f607e7ddaa7a7ce3d3f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a49bd48d4c5759f607e7ddaa7a7ce3d3f">isMrwType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a49bd48d4c5759f607e7ddaa7a7ce3d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a MRW image. <br/></td></tr>
<tr class="separator:a49bd48d4c5759f607e7ddaa7a7ce3d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eca2f83f7d21b63e7bd7b1ee9c2e16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51eca2f83f7d21b63e7bd7b1ee9c2e16"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a51eca2f83f7d21b63e7bd7b1ee9c2e16">newOrfInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a51eca2f83f7d21b63e7bd7b1ee9c2e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1OrfImage.html" title="Class to access raw Olympus ORF images. Exif metadata is supported directly, IPTC is read from the Ex...">OrfImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a51eca2f83f7d21b63e7bd7b1ee9c2e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cc9dd7270c22d05d95bf695f21d796"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87cc9dd7270c22d05d95bf695f21d796"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a87cc9dd7270c22d05d95bf695f21d796">isOrfType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a87cc9dd7270c22d05d95bf695f21d796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is an ORF image. <br/></td></tr>
<tr class="separator:a87cc9dd7270c22d05d95bf695f21d796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12242bf2733a1c9c88abb7a4318ee3db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12242bf2733a1c9c88abb7a4318ee3db"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a12242bf2733a1c9c88abb7a4318ee3db">newPgfInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a12242bf2733a1c9c88abb7a4318ee3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1PgfImage.html" title="Class to access PGF images. Exif and IPTC metadata are supported directly. ">PgfImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a12242bf2733a1c9c88abb7a4318ee3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4cc95dc380c767efbe94584b4df6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb4cc95dc380c767efbe94584b4df6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#addb4cc95dc380c767efbe94584b4df6a">isPgfType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:addb4cc95dc380c767efbe94584b4df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a PGF image. <br/></td></tr>
<tr class="separator:addb4cc95dc380c767efbe94584b4df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacaa0596e9c197b99985ca68174a4c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abacaa0596e9c197b99985ca68174a4c0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abacaa0596e9c197b99985ca68174a4c0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structExiv2_1_1XmpPropertyInfo.html">XmpPropertyInfo</a> &amp;propertyInfo)</td></tr>
<tr class="memdesc:abacaa0596e9c197b99985ca68174a4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for property info. <br/></td></tr>
<tr class="separator:abacaa0596e9c197b99985ca68174a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694f2f16c08f41217d0f1b3e0a80cef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a694f2f16c08f41217d0f1b3e0a80cef6"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a694f2f16c08f41217d0f1b3e0a80cef6">newPsdInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a694f2f16c08f41217d0f1b3e0a80cef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1PsdImage.html" title="Class to access raw Photoshop images. ">PsdImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a694f2f16c08f41217d0f1b3e0a80cef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1922df87be2eb2db5ca64ce1152cd9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1922df87be2eb2db5ca64ce1152cd9d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae1922df87be2eb2db5ca64ce1152cd9d">isPsdType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:ae1922df87be2eb2db5ca64ce1152cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a <a class="el" href="structExiv2_1_1Photoshop.html" title="Helper class, has methods to deal with Photoshop &quot;Information        Resource Blocks&quot; (IRBs)...">Photoshop</a> image. <br/></td></tr>
<tr class="separator:ae1922df87be2eb2db5ca64ce1152cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758f9e92d60d96920e5ce24c136e64d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a758f9e92d60d96920e5ce24c136e64d1"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a758f9e92d60d96920e5ce24c136e64d1">newQTimeInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a758f9e92d60d96920e5ce24c136e64d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new QuicktimeVideo instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a758f9e92d60d96920e5ce24c136e64d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af437212d7fe25ccddc931abb5efcbcdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af437212d7fe25ccddc931abb5efcbcdc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af437212d7fe25ccddc931abb5efcbcdc">isQTimeType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:af437212d7fe25ccddc931abb5efcbcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Quick Time Video. <br/></td></tr>
<tr class="separator:af437212d7fe25ccddc931abb5efcbcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5187e744341921e7c06b8ac494d11570"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5187e744341921e7c06b8ac494d11570"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5187e744341921e7c06b8ac494d11570">newRafInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a5187e744341921e7c06b8ac494d11570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1RafImage.html" title="Class to access raw Fujifilm RAF images. Exif metadata is supported directly, IPTC is read from the E...">RafImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a5187e744341921e7c06b8ac494d11570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90949be425b2396c454eb9084bebbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f90949be425b2396c454eb9084bebbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8f90949be425b2396c454eb9084bebbf">isRafType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a8f90949be425b2396c454eb9084bebbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a RAF image. <br/></td></tr>
<tr class="separator:a8f90949be425b2396c454eb9084bebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233497b39ee59e7a7bd4b4e7e3829491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233497b39ee59e7a7bd4b4e7e3829491"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a233497b39ee59e7a7bd4b4e7e3829491">newRiffInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a233497b39ee59e7a7bd4b4e7e3829491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1RiffVideo.html" title="Class to access RIFF video files. ">RiffVideo</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a233497b39ee59e7a7bd4b4e7e3829491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd5bbc2d1c8a279955910f5674114c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd5bbc2d1c8a279955910f5674114c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a9bd5bbc2d1c8a279955910f5674114c1">isRiffType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a9bd5bbc2d1c8a279955910f5674114c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Riff Video. <br/></td></tr>
<tr class="separator:a9bd5bbc2d1c8a279955910f5674114c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76129504f3c4a48a9c3eaeb823d302e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76129504f3c4a48a9c3eaeb823d302e1"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a76129504f3c4a48a9c3eaeb823d302e1">newRw2Instance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a76129504f3c4a48a9c3eaeb823d302e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1Rw2Image.html" title="Class to access raw Panasonic RW2 images. Exif metadata is supported directly, IPTC and XMP are read ...">Rw2Image</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a76129504f3c4a48a9c3eaeb823d302e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dc6a983c786692a5a6b100ae58cde3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31dc6a983c786692a5a6b100ae58cde3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a31dc6a983c786692a5a6b100ae58cde3">isRw2Type</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a31dc6a983c786692a5a6b100ae58cde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a RW2 image. <br/></td></tr>
<tr class="separator:a31dc6a983c786692a5a6b100ae58cde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9708095cd8ecc9e6b8134fa7b85ad8cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9708095cd8ecc9e6b8134fa7b85ad8cf"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a9708095cd8ecc9e6b8134fa7b85ad8cf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structExiv2_1_1TagInfo.html">TagInfo</a> &amp;ti)</td></tr>
<tr class="memdesc:a9708095cd8ecc9e6b8134fa7b85ad8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="structExiv2_1_1TagInfo.html" title="Tag information. ">TagInfo</a>. <br/></td></tr>
<tr class="separator:a9708095cd8ecc9e6b8134fa7b85ad8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b242299ac95dff1a18759ebed87b55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b242299ac95dff1a18759ebed87b55"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a43b242299ac95dff1a18759ebed87b55">newTgaInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a43b242299ac95dff1a18759ebed87b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1TgaImage.html" title="Class to access raw TARGA images. This is just a stub - we only read width and height. ">TgaImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a43b242299ac95dff1a18759ebed87b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e28192e762ae5664c12afe6677a2593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e28192e762ae5664c12afe6677a2593"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8e28192e762ae5664c12afe6677a2593">isTgaType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a8e28192e762ae5664c12afe6677a2593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a Targa v2 image. <br/></td></tr>
<tr class="separator:a8e28192e762ae5664c12afe6677a2593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0cd9bda3298bc22611cb18f672bb92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0cd9bda3298bc22611cb18f672bb92"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2e0cd9bda3298bc22611cb18f672bb92">newTiffInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a2e0cd9bda3298bc22611cb18f672bb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1TiffImage.html" title="Class to access TIFF images. Exif metadata is supported directly, IPTC is read from the Exif data...">TiffImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a2e0cd9bda3298bc22611cb18f672bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d5b19b7e5fcd822a1d8ef9eed4ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f5d5b19b7e5fcd822a1d8ef9eed4ca9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a6f5d5b19b7e5fcd822a1d8ef9eed4ca9">isTiffType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:a6f5d5b19b7e5fcd822a1d8ef9eed4ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a TIFF image. <br/></td></tr>
<tr class="separator:a6f5d5b19b7e5fcd822a1d8ef9eed4ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8f28fe68335865a3578c882a168e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8f28fe68335865a3578c882a168e63"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#adc8f28fe68335865a3578c882a168e63">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> &amp;r)</td></tr>
<tr class="memdesc:adc8f28fe68335865a3578c882a168e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for our fake rational. <br/></td></tr>
<tr class="separator:adc8f28fe68335865a3578c882a168e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24049f1e33ba6a1de401cc6c522e1bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24049f1e33ba6a1de401cc6c522e1bd4"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a24049f1e33ba6a1de401cc6c522e1bd4">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> &amp;r)</td></tr>
<tr class="memdesc:a24049f1e33ba6a1de401cc6c522e1bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input operator for our fake rational. <br/></td></tr>
<tr class="separator:a24049f1e33ba6a1de401cc6c522e1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c1f6ff6967a7ab3dccfdd21f8db71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c6c1f6ff6967a7ab3dccfdd21f8db71"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4c6c1f6ff6967a7ab3dccfdd21f8db71">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> &amp;r)</td></tr>
<tr class="memdesc:a4c6c1f6ff6967a7ab3dccfdd21f8db71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for our fake unsigned rational. <br/></td></tr>
<tr class="separator:a4c6c1f6ff6967a7ab3dccfdd21f8db71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1805e406e626f02bad01d20eb9421d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1805e406e626f02bad01d20eb9421d"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5f1805e406e626f02bad01d20eb9421d">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> &amp;r)</td></tr>
<tr class="memdesc:a5f1805e406e626f02bad01d20eb9421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input operator for our fake unsigned rational. <br/></td></tr>
<tr class="separator:a5f1805e406e626f02bad01d20eb9421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0bbd0d82b12d40d7ff78e54b91d9eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba0bbd0d82b12d40d7ff78e54b91d9eb"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aba0bbd0d82b12d40d7ff78e54b91d9eb">getUShort</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:aba0bbd0d82b12d40d7ff78e54b91d9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 2 byte unsigned short value from the data buffer. <br/></td></tr>
<tr class="separator:aba0bbd0d82b12d40d7ff78e54b91d9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac010ed4daa22c05b792ade639cda07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ac010ed4daa22c05b792ade639cda07"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2ac010ed4daa22c05b792ade639cda07">getULong</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a2ac010ed4daa22c05b792ade639cda07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 4 byte unsigned long value from the data buffer. <br/></td></tr>
<tr class="separator:a2ac010ed4daa22c05b792ade639cda07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd349c39a93e397914cef0e8c511d147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd349c39a93e397914cef0e8c511d147"></a>
<a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abd349c39a93e397914cef0e8c511d147">getURational</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:abd349c39a93e397914cef0e8c511d147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an 8 byte unsigned rational value from the data buffer. <br/></td></tr>
<tr class="separator:abd349c39a93e397914cef0e8c511d147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034a977f27f32a817d6846160f3723c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034a977f27f32a817d6846160f3723c9"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a034a977f27f32a817d6846160f3723c9">getShort</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a034a977f27f32a817d6846160f3723c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 2 byte signed short value from the data buffer. <br/></td></tr>
<tr class="separator:a034a977f27f32a817d6846160f3723c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa13407701ef70800058a760e8be52e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaa13407701ef70800058a760e8be52e"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aaaa13407701ef70800058a760e8be52e">getLong</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:aaaa13407701ef70800058a760e8be52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 4 byte signed long value from the data buffer. <br/></td></tr>
<tr class="separator:aaaa13407701ef70800058a760e8be52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99d0bb9a8a2d8ae0b85e2a556325d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f99d0bb9a8a2d8ae0b85e2a556325d4"></a>
<a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4f99d0bb9a8a2d8ae0b85e2a556325d4">getRational</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a4f99d0bb9a8a2d8ae0b85e2a556325d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an 8 byte signed rational value from the data buffer. <br/></td></tr>
<tr class="separator:a4f99d0bb9a8a2d8ae0b85e2a556325d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222c7a2b5ba8f0f195a52231c83fe1eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a222c7a2b5ba8f0f195a52231c83fe1eb"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a222c7a2b5ba8f0f195a52231c83fe1eb">getFloat</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a222c7a2b5ba8f0f195a52231c83fe1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 4 byte single precision floating point value (IEEE 754 binary32) from the data buffer. <br/></td></tr>
<tr class="separator:a222c7a2b5ba8f0f195a52231c83fe1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1645cade15ccc7979d93c5011b1305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca1645cade15ccc7979d93c5011b1305"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aca1645cade15ccc7979d93c5011b1305">getDouble</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:aca1645cade15ccc7979d93c5011b1305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an 8 byte double precision floating point value (IEEE 754 binary64) from the data buffer. <br/></td></tr>
<tr class="separator:aca1645cade15ccc7979d93c5011b1305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553bcd11ca439ab9f6783ee594e85bd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553bcd11ca439ab9f6783ee594e85bd6"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a553bcd11ca439ab9f6783ee594e85bd6">us2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, uint16_t s, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a553bcd11ca439ab9f6783ee594e85bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned short to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:a553bcd11ca439ab9f6783ee594e85bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40b07808b158c7d196d12d55c677338"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac40b07808b158c7d196d12d55c677338"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac40b07808b158c7d196d12d55c677338">ul2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, uint32_t l, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:ac40b07808b158c7d196d12d55c677338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned long to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:ac40b07808b158c7d196d12d55c677338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4ad1141383dad6aa8bf889c20540cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4ad1141383dad6aa8bf889c20540cc"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abe4ad1141383dad6aa8bf889c20540cc">ur2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> l, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:abe4ad1141383dad6aa8bf889c20540cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned rational to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:abe4ad1141383dad6aa8bf889c20540cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23477f61cedcffab169f291d8f9bf635"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23477f61cedcffab169f291d8f9bf635"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a23477f61cedcffab169f291d8f9bf635">s2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, int16_t s, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a23477f61cedcffab169f291d8f9bf635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signed short to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:a23477f61cedcffab169f291d8f9bf635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5602b3f96554d7eb6fc778abebd8c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5602b3f96554d7eb6fc778abebd8c0"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#adf5602b3f96554d7eb6fc778abebd8c0">l2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, int32_t l, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:adf5602b3f96554d7eb6fc778abebd8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signed long to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:adf5602b3f96554d7eb6fc778abebd8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae626dcc00cb44f8f00acdbac2da00439"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae626dcc00cb44f8f00acdbac2da00439"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae626dcc00cb44f8f00acdbac2da00439">r2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> l, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:ae626dcc00cb44f8f00acdbac2da00439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signed rational to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:ae626dcc00cb44f8f00acdbac2da00439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce18941bef037f98fe7c119b24da2fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ce18941bef037f98fe7c119b24da2fa"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a0ce18941bef037f98fe7c119b24da2fa">f2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, float f, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a0ce18941bef037f98fe7c119b24da2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single precision floating point (IEEE 754 binary32) float to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:a0ce18941bef037f98fe7c119b24da2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b84e90717b7fdffc136cff7a99976df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b84e90717b7fdffc136cff7a99976df"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a7b84e90717b7fdffc136cff7a99976df">d2Data</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, double d, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a7b84e90717b7fdffc136cff7a99976df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a double precision floating point (IEEE 754 binary64) double to data, write the data to the buffer, return number of bytes written. <br/></td></tr>
<tr class="separator:a7b84e90717b7fdffc136cff7a99976df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c7b79205556288e3c967798a4c5c41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c7b79205556288e3c967798a4c5c41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a95c7b79205556288e3c967798a4c5c41">hexdump</a> (std::ostream &amp;os, const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, long len, long offset=0)</td></tr>
<tr class="memdesc:a95c7b79205556288e3c967798a4c5c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print len bytes from buf in hex and ASCII format to the given stream, prefixed with the position in the buffer adjusted by offset. <br/></td></tr>
<tr class="separator:a95c7b79205556288e3c967798a4c5c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf961ae77342e4c754b981c51036948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf961ae77342e4c754b981c51036948"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#acaf961ae77342e4c754b981c51036948">isHex</a> (const std::string &amp;str, size_t size=0, const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:acaf961ae77342e4c754b981c51036948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if str is a hex number starting with prefix followed by size hex digits, false otherwise. If size is 0, any number of digits is allowed and all are checked. <br/></td></tr>
<tr class="separator:acaf961ae77342e4c754b981c51036948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72b70889b5efd94e92446fc37ae379"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc72b70889b5efd94e92446fc37ae379"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abc72b70889b5efd94e92446fc37ae379">exifTime</a> (const char *buf, struct tm *tm)</td></tr>
<tr class="memdesc:abc72b70889b5efd94e92446fc37ae379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string in the form "%Y:%m:%d %H:%M:%S", e.g., "2007:05:24 12:31:55" to broken down time format, returns 0 if successful, else 1. <br/></td></tr>
<tr class="separator:abc72b70889b5efd94e92446fc37ae379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b13ac9cb8855334ebe6b4b833e9e311"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b13ac9cb8855334ebe6b4b833e9e311"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2b13ac9cb8855334ebe6b4b833e9e311">exvGettext</a> (const char *str)</td></tr>
<tr class="memdesc:a2b13ac9cb8855334ebe6b4b833e9e311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a string using the gettext framework. This wrapper hides all the implementation details from the interface. <br/></td></tr>
<tr class="separator:a2b13ac9cb8855334ebe6b4b833e9e311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5584318f5a20a6e35420d04d99c60bc3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5584318f5a20a6e35420d04d99c60bc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5584318f5a20a6e35420d04d99c60bc3">stringTo&lt; bool &gt;</a> (const std::string &amp;s, bool &amp;ok)</td></tr>
<tr class="memdesc:a5584318f5a20a6e35420d04d99c60bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001" title="Utility function to convert a string to a value of type T. ">stringTo(const std::string&amp; s, bool&amp; ok)</a> for <em>bool</em>.  <a href="#a5584318f5a20a6e35420d04d99c60bc3">More...</a><br/></td></tr>
<tr class="separator:a5584318f5a20a6e35420d04d99c60bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409855f9f68490e5d791b1bffc6a708"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1409855f9f68490e5d791b1bffc6a708">parseLong</a> (const std::string &amp;s, bool &amp;ok)</td></tr>
<tr class="memdesc:a1409855f9f68490e5d791b1bffc6a708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <em>long</em> set to the value represented by <em>s</em>.  <a href="#a1409855f9f68490e5d791b1bffc6a708">More...</a><br/></td></tr>
<tr class="separator:a1409855f9f68490e5d791b1bffc6a708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3bf069dab26d8a8b945de0b546b27"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a61c3bf069dab26d8a8b945de0b546b27">parseFloat</a> (const std::string &amp;s, bool &amp;ok)</td></tr>
<tr class="memdesc:a61c3bf069dab26d8a8b945de0b546b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <em>float</em> set to the value represented by <em>s</em>.  <a href="#a61c3bf069dab26d8a8b945de0b546b27">More...</a><br/></td></tr>
<tr class="separator:a61c3bf069dab26d8a8b945de0b546b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c754e9c64ad5daa1f0fc5a32b88e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ad0c754e9c64ad5daa1f0fc5a32b88e1f">parseRational</a> (const std::string &amp;s, bool &amp;ok)</td></tr>
<tr class="memdesc:ad0c754e9c64ad5daa1f0fc5a32b88e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <em>Rational</em> set to the value represented by <em>s</em>.  <a href="#ad0c754e9c64ad5daa1f0fc5a32b88e1f">More...</a><br/></td></tr>
<tr class="separator:ad0c754e9c64ad5daa1f0fc5a32b88e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caa281728674d5138df8907be61c00e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a6caa281728674d5138df8907be61c00e">floatToRationalCast</a> (float f)</td></tr>
<tr class="memdesc:a6caa281728674d5138df8907be61c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple conversion of a <em>float</em> to a <em>Rational</em>.  <a href="#a6caa281728674d5138df8907be61c00e">More...</a><br/></td></tr>
<tr class="separator:a6caa281728674d5138df8907be61c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add349cd7b6bc3b9566d00f8d41c08fe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add349cd7b6bc3b9566d00f8d41c08fe3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#add349cd7b6bc3b9566d00f8d41c08fe3">versionNumber</a> ()</td></tr>
<tr class="memdesc:add349cd7b6bc3b9566d00f8d41c08fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of Exiv2 available at runtime as an integer. <br/></td></tr>
<tr class="separator:add349cd7b6bc3b9566d00f8d41c08fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7598028a8f244d25959c8c6b6baa64f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7598028a8f244d25959c8c6b6baa64f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af7598028a8f244d25959c8c6b6baa64f">versionString</a> ()</td></tr>
<tr class="memdesc:af7598028a8f244d25959c8c6b6baa64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version string Example: "0.23.0" (major.minor.patch) <br/></td></tr>
<tr class="separator:af7598028a8f244d25959c8c6b6baa64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e10034c300522d4f9ef232ba46a8ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e10034c300522d4f9ef232ba46a8ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ad6e10034c300522d4f9ef232ba46a8ba">versionNumberHexString</a> ()</td></tr>
<tr class="memdesc:ad6e10034c300522d4f9ef232ba46a8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of Exiv2 as hex string of fixed length 6. <br/></td></tr>
<tr class="separator:ad6e10034c300522d4f9ef232ba46a8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc2141c839d15abc9f1473e8cc701fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc2141c839d15abc9f1473e8cc701fd"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8bc2141c839d15abc9f1473e8cc701fd">version</a> ()</td></tr>
<tr class="memdesc:a8bc2141c839d15abc9f1473e8cc701fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of Exiv2 available at runtime as a string. <br/></td></tr>
<tr class="separator:a8bc2141c839d15abc9f1473e8cc701fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d8f92acdf4d23b673225584405fba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ad8d8f92acdf4d23b673225584405fba5">testVersion</a> (int major, int minor, int patch)</td></tr>
<tr class="memdesc:ad8d8f92acdf4d23b673225584405fba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the version of the available Exiv2 library at runtime. Return true if it is the same as or newer than the passed-in version.  <a href="#ad8d8f92acdf4d23b673225584405fba5">More...</a><br/></td></tr>
<tr class="separator:ad8d8f92acdf4d23b673225584405fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c23a300c7a8b7e87ff1a5c540b65738"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c23a300c7a8b7e87ff1a5c540b65738"></a>
<a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a1c23a300c7a8b7e87ff1a5c540b65738">newXmpInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a1c23a300c7a8b7e87ff1a5c540b65738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1XmpSidecar.html" title="Class to access XMP sidecar files. They contain only XMP metadata. ">XmpSidecar</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a1c23a300c7a8b7e87ff1a5c540b65738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5e294dbd9da3393aa3ceb205409660"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb5e294dbd9da3393aa3ceb205409660"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aeb5e294dbd9da3393aa3ceb205409660">isXmpType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:aeb5e294dbd9da3393aa3ceb205409660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is an XMP sidecar file. <br/></td></tr>
<tr class="separator:aeb5e294dbd9da3393aa3ceb205409660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc468104de8f48f9324a9c592eb3bdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc468104de8f48f9324a9c592eb3bdb"></a>
EXIV2API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2dc468104de8f48f9324a9c592eb3bdb">curlWriter</a> (char *data, size_t size, size_t nmemb, std::string *writerData)</td></tr>
<tr class="memdesc:a2dc468104de8f48f9324a9c592eb3bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function is called by libcurl to write the data. <br/></td></tr>
<tr class="separator:a2dc468104de8f48f9324a9c592eb3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e630a62be27d591d7d6a11464983b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b5e630a62be27d591d7d6a11464983b"></a>
template&lt;typename charT , typename T &gt; </td></tr>
<tr class="memitem:a5b5e630a62be27d591d7d6a11464983b"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; charT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a5b5e630a62be27d591d7d6a11464983b">toBasicString</a> (const T &amp;arg)</td></tr>
<tr class="memdesc:a5b5e630a62be27d591d7d6a11464983b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalised toString function. <br/></td></tr>
<tr class="separator:a5b5e630a62be27d591d7d6a11464983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984441dbc42706388541913499c48384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a984441dbc42706388541913499c48384"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a984441dbc42706388541913499c48384">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classExiv2_1_1AnyError.html">AnyError</a> &amp;error)</td></tr>
<tr class="memdesc:a984441dbc42706388541913499c48384"><td class="mdescLeft">&#160;</td><td class="mdescRight">AnyError output operator <br/></td></tr>
<tr class="separator:a984441dbc42706388541913499c48384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3e8d6d9641d9cfcb5d2b161521e4f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3e8d6d9641d9cfcb5d2b161521e4f3"></a>
EXIV2API int&#160;</td><td class="memItemRight" valign="bottom"><b>http</b> (dict_t &amp;request, dict_t &amp;response, std::string &amp;errors)</td></tr>
<tr class="separator:a3c3e8d6d9641d9cfcb5d2b161521e4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa225826fb028de2941da4230b51dfb95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa225826fb028de2941da4230b51dfb95"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aa225826fb028de2941da4230b51dfb95">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classExiv2_1_1Key.html">Key</a> &amp;key)</td></tr>
<tr class="memdesc:aa225826fb028de2941da4230b51dfb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="classExiv2_1_1Key.html" title="Abstract base class defining the Key of a metadatum. Keys are used to identify and group metadata...">Key</a> types. <br/></td></tr>
<tr class="separator:aa225826fb028de2941da4230b51dfb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8525be11fc92fcb2bd88e886daa1959a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8525be11fc92fcb2bd88e886daa1959a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a8525be11fc92fcb2bd88e886daa1959a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classExiv2_1_1Metadatum.html">Metadatum</a> &amp;md)</td></tr>
<tr class="memdesc:a8525be11fc92fcb2bd88e886daa1959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="classExiv2_1_1Metadatum.html" title="Abstract base class defining the interface to access information related to one metadata tag...">Metadatum</a> types, writing the interpreted tag value. <br/></td></tr>
<tr class="separator:a8525be11fc92fcb2bd88e886daa1959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3222339b57a62d96c8ac5b38e2a7ccf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3222339b57a62d96c8ac5b38e2a7ccf1"></a>
EXIV2API <a class="el" href="classExiv2_1_1Image.html#a89ad3ffe7a4e8a943d267d77843415fb">Image::AutoPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a3222339b57a62d96c8ac5b38e2a7ccf1">newPngInstance</a> (<a class="el" href="classExiv2_1_1BasicIo.html#af8f989522925b884d8c9d3a257265fa1">BasicIo::AutoPtr</a> io, bool create)</td></tr>
<tr class="memdesc:a3222339b57a62d96c8ac5b38e2a7ccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classExiv2_1_1PngImage.html" title="Class to access PNG images. Exif and IPTC metadata are supported directly. ">PngImage</a> instance and return an auto-pointer to it. Caller owns the returned object and the auto-pointer ensures that it will be deleted. <br/></td></tr>
<tr class="separator:a3222339b57a62d96c8ac5b38e2a7ccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f35a1ff80fbea87aec202f8ddb69c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f35a1ff80fbea87aec202f8ddb69c7"></a>
EXIV2API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aa8f35a1ff80fbea87aec202f8ddb69c7">isPngType</a> (<a class="el" href="classExiv2_1_1BasicIo.html">BasicIo</a> &amp;iIo, bool advance)</td></tr>
<tr class="memdesc:aa8f35a1ff80fbea87aec202f8ddb69c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file iIo is a PNG image. <br/></td></tr>
<tr class="separator:aa8f35a1ff80fbea87aec202f8ddb69c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea35ee7a596e1d47d1ffbb553cfb688d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename K , int N&gt; </td></tr>
<tr class="memitem:aea35ee7a596e1d47d1ffbb553cfb688d"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aea35ee7a596e1d47d1ffbb553cfb688d">find</a> (T(&amp;src)[N], const K &amp;key)</td></tr>
<tr class="memdesc:aea35ee7a596e1d47d1ffbb553cfb688d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element that matches <em>key</em> in the array <em>src</em>.  <a href="#aea35ee7a596e1d47d1ffbb553cfb688d">More...</a><br/></td></tr>
<tr class="separator:aea35ee7a596e1d47d1ffbb553cfb688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911990ae8d2f4f47554fb493fcf31e25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a911990ae8d2f4f47554fb493fcf31e25"></a>
template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a911990ae8d2f4f47554fb493fcf31e25"><td class="memTemplItemLeft" align="right" valign="top">char(&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a911990ae8d2f4f47554fb493fcf31e25">sizer</a> (T(&amp;)[N]))[N]</td></tr>
<tr class="memdesc:a911990ae8d2f4f47554fb493fcf31e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used in the COUNTOF macro to determine the size of an array. <br/></td></tr>
<tr class="separator:a911990ae8d2f4f47554fb493fcf31e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a1b7e0a14e8671707d5be16cbda24"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb5a1b7e0a14e8671707d5be16cbda24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb5a1b7e0a14e8671707d5be16cbda24"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aeb5a1b7e0a14e8671707d5be16cbda24">toString</a> (const T &amp;arg)</td></tr>
<tr class="memdesc:aeb5a1b7e0a14e8671707d5be16cbda24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to convert the argument of any type to a string. <br/></td></tr>
<tr class="separator:aeb5a1b7e0a14e8671707d5be16cbda24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8949fc0e956f239c26489e87c7001"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94f8949fc0e956f239c26489e87c7001"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001">stringTo</a> (const std::string &amp;s, bool &amp;ok)</td></tr>
<tr class="memdesc:a94f8949fc0e956f239c26489e87c7001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to convert a string to a value of type <code>T</code>.  <a href="#a94f8949fc0e956f239c26489e87c7001">More...</a><br/></td></tr>
<tr class="separator:a94f8949fc0e956f239c26489e87c7001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dc44cabbd590c8083ed6eeab81c92d"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a36dc44cabbd590c8083ed6eeab81c92d"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a36dc44cabbd590c8083ed6eeab81c92d">gcd</a> (IntType n, IntType m)</td></tr>
<tr class="memdesc:a36dc44cabbd590c8083ed6eeab81c92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest common denominator of n and m. (Implementation from Boost rational.hpp)  <a href="#a36dc44cabbd590c8083ed6eeab81c92d">More...</a><br/></td></tr>
<tr class="separator:a36dc44cabbd590c8083ed6eeab81c92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe882054db13fc2f4f6f7e8e1261d982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe882054db13fc2f4f6f7e8e1261d982"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#abe882054db13fc2f4f6f7e8e1261d982">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classExiv2_1_1Value.html">Value</a> &amp;value)</td></tr>
<tr class="memdesc:abe882054db13fc2f4f6f7e8e1261d982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> types. <br/></td></tr>
<tr class="separator:abe882054db13fc2f4f6f7e8e1261d982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b83a1433a7a18fcf0a09b082714f3b"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0b83a1433a7a18fcf0a09b082714f3b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0b83a1433a7a18fcf0a09b082714f3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af0b83a1433a7a18fcf0a09b082714f3b">getType</a> ()</td></tr>
<tr class="memdesc:af0b83a1433a7a18fcf0a09b082714f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to determine the TypeId for a type T. <br/></td></tr>
<tr class="separator:af0b83a1433a7a18fcf0a09b082714f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0279140f957f833817960b2ea5de1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95d0279140f957f833817960b2ea5de1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a95d0279140f957f833817960b2ea5de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a95d0279140f957f833817960b2ea5de1">getType&lt; uint16_t &gt;</a> ()</td></tr>
<tr class="memdesc:a95d0279140f957f833817960b2ea5de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for an unsigned short. <br/></td></tr>
<tr class="separator:a95d0279140f957f833817960b2ea5de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4030bbc9f931a5bb0e0e2b89e1b84c3b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4030bbc9f931a5bb0e0e2b89e1b84c3b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4030bbc9f931a5bb0e0e2b89e1b84c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4030bbc9f931a5bb0e0e2b89e1b84c3b">getType&lt; uint32_t &gt;</a> ()</td></tr>
<tr class="memdesc:a4030bbc9f931a5bb0e0e2b89e1b84c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for an unsigned long. <br/></td></tr>
<tr class="separator:a4030bbc9f931a5bb0e0e2b89e1b84c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b036b9adbec5f8ba12cd95802aa7e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6b036b9adbec5f8ba12cd95802aa7e0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac6b036b9adbec5f8ba12cd95802aa7e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac6b036b9adbec5f8ba12cd95802aa7e0">getType&lt; URational &gt;</a> ()</td></tr>
<tr class="memdesc:ac6b036b9adbec5f8ba12cd95802aa7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for an unsigned rational. <br/></td></tr>
<tr class="separator:ac6b036b9adbec5f8ba12cd95802aa7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bef63bc2a51373348b1d42b8259bf0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22bef63bc2a51373348b1d42b8259bf0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a22bef63bc2a51373348b1d42b8259bf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a22bef63bc2a51373348b1d42b8259bf0">getType&lt; int16_t &gt;</a> ()</td></tr>
<tr class="memdesc:a22bef63bc2a51373348b1d42b8259bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for a signed short. <br/></td></tr>
<tr class="separator:a22bef63bc2a51373348b1d42b8259bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb321a38aa3b97b8c0cba97109454b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0bb321a38aa3b97b8c0cba97109454b2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0bb321a38aa3b97b8c0cba97109454b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a0bb321a38aa3b97b8c0cba97109454b2">getType&lt; int32_t &gt;</a> ()</td></tr>
<tr class="memdesc:a0bb321a38aa3b97b8c0cba97109454b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for a signed long. <br/></td></tr>
<tr class="separator:a0bb321a38aa3b97b8c0cba97109454b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc773aa4c41b1c6238f685ee68e115"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbbc773aa4c41b1c6238f685ee68e115"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adbbc773aa4c41b1c6238f685ee68e115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#adbbc773aa4c41b1c6238f685ee68e115">getType&lt; Rational &gt;</a> ()</td></tr>
<tr class="memdesc:adbbc773aa4c41b1c6238f685ee68e115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for a signed rational. <br/></td></tr>
<tr class="separator:adbbc773aa4c41b1c6238f685ee68e115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb1098a652ad03ba7b5f3cf65e2fea6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aceb1098a652ad03ba7b5f3cf65e2fea6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aceb1098a652ad03ba7b5f3cf65e2fea6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aceb1098a652ad03ba7b5f3cf65e2fea6">getType&lt; float &gt;</a> ()</td></tr>
<tr class="memdesc:aceb1098a652ad03ba7b5f3cf65e2fea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for a float. <br/></td></tr>
<tr class="separator:aceb1098a652ad03ba7b5f3cf65e2fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6101a28515811201e35333b3785029"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade6101a28515811201e35333b3785029"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ade6101a28515811201e35333b3785029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">TypeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ade6101a28515811201e35333b3785029">getType&lt; double &gt;</a> ()</td></tr>
<tr class="memdesc:ade6101a28515811201e35333b3785029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for a double. <br/></td></tr>
<tr class="separator:ade6101a28515811201e35333b3785029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4901857878dd5ae68afb2f6d075993fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4901857878dd5ae68afb2f6d075993fc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4901857878dd5ae68afb2f6d075993fc">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a4901857878dd5ae68afb2f6d075993fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#a4901857878dd5ae68afb2f6d075993fc">More...</a><br/></td></tr>
<tr class="separator:a4901857878dd5ae68afb2f6d075993fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018b02b6bb14db1f15fdc51d18707166"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a018b02b6bb14db1f15fdc51d18707166"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a018b02b6bb14db1f15fdc51d18707166">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a018b02b6bb14db1f15fdc51d18707166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#a018b02b6bb14db1f15fdc51d18707166">More...</a><br/></td></tr>
<tr class="separator:a018b02b6bb14db1f15fdc51d18707166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c794910171e9fc803354c1840d658d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a81c794910171e9fc803354c1840d658d"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a81c794910171e9fc803354c1840d658d">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a81c794910171e9fc803354c1840d658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#a81c794910171e9fc803354c1840d658d">More...</a><br/></td></tr>
<tr class="separator:a81c794910171e9fc803354c1840d658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d0a94bfc9cfcbf0d7dbc70d6e2d818"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae2d0a94bfc9cfcbf0d7dbc70d6e2d818"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae2d0a94bfc9cfcbf0d7dbc70d6e2d818">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:ae2d0a94bfc9cfcbf0d7dbc70d6e2d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#ae2d0a94bfc9cfcbf0d7dbc70d6e2d818">More...</a><br/></td></tr>
<tr class="separator:ae2d0a94bfc9cfcbf0d7dbc70d6e2d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecdbbe9c009a5f96a5f85ade05bd28e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afecdbbe9c009a5f96a5f85ade05bd28e"><td class="memTemplItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afecdbbe9c009a5f96a5f85ade05bd28e">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:afecdbbe9c009a5f96a5f85ade05bd28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#afecdbbe9c009a5f96a5f85ade05bd28e">More...</a><br/></td></tr>
<tr class="separator:afecdbbe9c009a5f96a5f85ade05bd28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7355853dc6a1b516eafd9a398c1d5a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3d7355853dc6a1b516eafd9a398c1d5a"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a3d7355853dc6a1b516eafd9a398c1d5a">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a3d7355853dc6a1b516eafd9a398c1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#a3d7355853dc6a1b516eafd9a398c1d5a">More...</a><br/></td></tr>
<tr class="separator:a3d7355853dc6a1b516eafd9a398c1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119c6400314a13c2f7dd5710adb734a1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a119c6400314a13c2f7dd5710adb734a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a119c6400314a13c2f7dd5710adb734a1">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a119c6400314a13c2f7dd5710adb734a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#a119c6400314a13c2f7dd5710adb734a1">More...</a><br/></td></tr>
<tr class="separator:a119c6400314a13c2f7dd5710adb734a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92314aa203ce8a3d30aa52117496dd8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af92314aa203ce8a3d30aa52117496dd8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af92314aa203ce8a3d30aa52117496dd8">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:af92314aa203ce8a3d30aa52117496dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#af92314aa203ce8a3d30aa52117496dd8">More...</a><br/></td></tr>
<tr class="separator:af92314aa203ce8a3d30aa52117496dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9a94996ef8406470309bb4cce9ac4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae4e9a94996ef8406470309bb4cce9ac4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ae4e9a94996ef8406470309bb4cce9ac4">getValue</a> (const <a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:ae4e9a94996ef8406470309bb4cce9ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value of type T from the data buffer.  <a href="#ae4e9a94996ef8406470309bb4cce9ac4">More...</a><br/></td></tr>
<tr class="separator:ae4e9a94996ef8406470309bb4cce9ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59acfb133eebbee93865f1cc07106bca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59acfb133eebbee93865f1cc07106bca"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a59acfb133eebbee93865f1cc07106bca">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, T t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a59acfb133eebbee93865f1cc07106bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a value of type T to data, write the data to the data buffer.  <a href="#a59acfb133eebbee93865f1cc07106bca">More...</a><br/></td></tr>
<tr class="separator:a59acfb133eebbee93865f1cc07106bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70293ab419ea7ebc377c2d7d939f1e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac70293ab419ea7ebc377c2d7d939f1e2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac70293ab419ea7ebc377c2d7d939f1e2"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#ac70293ab419ea7ebc377c2d7d939f1e2">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, uint16_t t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:ac70293ab419ea7ebc377c2d7d939f1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write an unsigned short to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:ac70293ab419ea7ebc377c2d7d939f1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad3813e1f2ee3b581a0a243532d6525"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ad3813e1f2ee3b581a0a243532d6525"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2ad3813e1f2ee3b581a0a243532d6525"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a2ad3813e1f2ee3b581a0a243532d6525">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, uint32_t t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a2ad3813e1f2ee3b581a0a243532d6525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write an unsigned long to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a2ad3813e1f2ee3b581a0a243532d6525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca265f73d131bb3172a5e57e5e676f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ca265f73d131bb3172a5e57e5e676f4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4ca265f73d131bb3172a5e57e5e676f4"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a4ca265f73d131bb3172a5e57e5e676f4">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a4ca265f73d131bb3172a5e57e5e676f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write an unsigned rational to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a4ca265f73d131bb3172a5e57e5e676f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f4a2f6a321047f7c350be75f4d25f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5f4a2f6a321047f7c350be75f4d25f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa5f4a2f6a321047f7c350be75f4d25f3"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#aa5f4a2f6a321047f7c350be75f4d25f3">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, int16_t t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:aa5f4a2f6a321047f7c350be75f4d25f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write a signed short to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:aa5f4a2f6a321047f7c350be75f4d25f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daeaacc9cd9455c4f86fd6df8f6c800"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0daeaacc9cd9455c4f86fd6df8f6c800"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0daeaacc9cd9455c4f86fd6df8f6c800"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a0daeaacc9cd9455c4f86fd6df8f6c800">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, int32_t t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a0daeaacc9cd9455c4f86fd6df8f6c800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write a signed long to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a0daeaacc9cd9455c4f86fd6df8f6c800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782c3e4630f01b71d37f71faebef4f11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a782c3e4630f01b71d37f71faebef4f11"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a782c3e4630f01b71d37f71faebef4f11"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a782c3e4630f01b71d37f71faebef4f11">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a782c3e4630f01b71d37f71faebef4f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write a signed rational to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a782c3e4630f01b71d37f71faebef4f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626f54e7ff31e31350cba021eced7833"><td class="memTemplParams" colspan="2"><a class="anchor" id="a626f54e7ff31e31350cba021eced7833"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a626f54e7ff31e31350cba021eced7833"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a626f54e7ff31e31350cba021eced7833">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, float t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a626f54e7ff31e31350cba021eced7833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write a float to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a626f54e7ff31e31350cba021eced7833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cdfa085d78f41dcd91364c85fa0056"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21cdfa085d78f41dcd91364c85fa0056"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a21cdfa085d78f41dcd91364c85fa0056"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#a21cdfa085d78f41dcd91364c85fa0056">toData</a> (<a class="el" href="namespaceExiv2.html#a16f60a5bd4207fe155f6cf93a15efa72">byte</a> *buf, double t, <a class="el" href="namespaceExiv2.html#a94c225faf6d6c611a3828fae1c28efa6">ByteOrder</a> byteOrder)</td></tr>
<tr class="memdesc:a21cdfa085d78f41dcd91364c85fa0056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to write a double to the data buffer. Return the number of bytes written. <br/></td></tr>
<tr class="separator:a21cdfa085d78f41dcd91364c85fa0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8ce4634d9d52e5ce3b23560ad4b151d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ce4634d9d52e5ce3b23560ad4b151d0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ENVARDEF</b> [] = {&quot;exiv2.php&quot;}</td></tr>
<tr class="separator:a8ce4634d9d52e5ce3b23560ad4b151d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab53d65ca465ed8a859ca8f187b1e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab53d65ca465ed8a859ca8f187b1e3c"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ENVARKEY</b> [] = {&quot;EXIV2_HTTP_POST&quot;}</td></tr>
<tr class="separator:abab53d65ca465ed8a859ca8f187b1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa59b81ff2fdb13ee24f5b3a479454c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa59b81ff2fdb13ee24f5b3a479454c2"></a>
const <a class="el" href="structExiv2_1_1GroupInfo.html">GroupInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#afa59b81ff2fdb13ee24f5b3a479454c2">groupInfo</a> []</td></tr>
<tr class="memdesc:afa59b81ff2fdb13ee24f5b3a479454c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all known Exif groups. Important: Group name (3rd column) must be unique! <br/></td></tr>
<tr class="separator:afa59b81ff2fdb13ee24f5b3a479454c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4879bfd704a610f3fe65e1476df6609"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExiv2_1_1Internal_1_1SectionInfo.html">SectionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#af4879bfd704a610f3fe65e1476df6609">sectionInfo</a> []</td></tr>
<tr class="memdesc:af4879bfd704a610f3fe65e1476df6609"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all defined Exif sections.  <a href="#af4879bfd704a610f3fe65e1476df6609">More...</a><br/></td></tr>
<tr class="separator:af4879bfd704a610f3fe65e1476df6609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda2ec7f698d8dbf322a6152945682ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structExiv2_1_1MimeTypeList.html">MimeTypeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceExiv2.html#adda2ec7f698d8dbf322a6152945682ce">mimeTypeList</a> []</td></tr>
<tr class="memdesc:adda2ec7f698d8dbf322a6152945682ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of TIFF compression to MIME type mappings.  <a href="#adda2ec7f698d8dbf322a6152945682ce">More...</a><br/></td></tr>
<tr class="separator:adda2ec7f698d8dbf322a6152945682ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides classes and functions to encode and decode Exif and Iptc data. The <b>libexiv2</b> API consists of the objects of this namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5153319711f35fe81cbc13f4b852450c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450c">Exiv2::TypeId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exiv2 value type identifiers. </p>
<p>Used primarily as identifiers when creating Exiv2 <a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> instances. See <a class="el" href="classExiv2_1_1Value.html#a7a6c027316e3dec0f7e79430f104c137" title="A (simple) factory to create a Value type. ">Value::create</a>. 0x0000 to 0xffff are reserved for TIFF (Exif) types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca6abd8e6e48dddae9bac03019ae907795"></a>unsignedByte</em>&nbsp;</td><td class="fielddoc">
<p>Exif BYTE type, 8-bit unsigned integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca773cf6dde5caaabb3dcf9fb161fa7dfd"></a>asciiString</em>&nbsp;</td><td class="fielddoc">
<p>Exif ASCII type, 8-bit byte. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca0329efdda8becff3ecf89bfbc816f72c"></a>unsignedShort</em>&nbsp;</td><td class="fielddoc">
<p>Exif SHORT type, 16-bit (2-byte) unsigned integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca3b506c0729276e4de3a0ab4d9b2226bd"></a>unsignedLong</em>&nbsp;</td><td class="fielddoc">
<p>Exif LONG type, 32-bit (4-byte) unsigned integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450cae450f64413c928b527cfdd73129d6606"></a>unsignedRational</em>&nbsp;</td><td class="fielddoc">
<p>Exif RATIONAL type, two LONGs: numerator and denumerator of a fraction. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca717f7d50dd484167359361d2c560f83c"></a>signedByte</em>&nbsp;</td><td class="fielddoc">
<p>Exif SBYTE type, an 8-bit signed (twos-complement) integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450caa044ece6f004f519dce91f57319bb6eb"></a>undefined</em>&nbsp;</td><td class="fielddoc">
<p>Exif UNDEFINED type, an 8-bit byte that may contain anything. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca4a46f8aa5e64d33468602515f6255b65"></a>signedShort</em>&nbsp;</td><td class="fielddoc">
<p>Exif SSHORT type, a 16-bit (2-byte) signed (twos-complement) integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca501fdf1b61472bff3b4da19b956eabda"></a>signedLong</em>&nbsp;</td><td class="fielddoc">
<p>Exif SLONG type, a 32-bit (4-byte) signed (twos-complement) integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca0d777a3a2542fbff07ed29563167b3b5"></a>signedRational</em>&nbsp;</td><td class="fielddoc">
<p>Exif SRATIONAL type, two SLONGs: numerator and denumerator of a fraction. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450cabcc0eb22efc41f32ba573c18731b4928"></a>tiffFloat</em>&nbsp;</td><td class="fielddoc">
<p>TIFF FLOAT type, single precision (4-byte) IEEE format. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca9b4d2fa208df5c86d24f7d7c41bd09a2"></a>tiffDouble</em>&nbsp;</td><td class="fielddoc">
<p>TIFF DOUBLE type, double precision (8-byte) IEEE format. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450cae9896f64a72a68e176f02c1880b19681"></a>tiffIfd</em>&nbsp;</td><td class="fielddoc">
<p>TIFF IFD type, 32-bit (4-byte) unsigned integer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca2d79fb07c9ec891f281968dad43c1e25"></a>string</em>&nbsp;</td><td class="fielddoc">
<p>IPTC string type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca0c347d8ddbbad9440f9bb6db8a06fa45"></a>date</em>&nbsp;</td><td class="fielddoc">
<p>IPTC date type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca8526caf002a100bd730312d45808f1b6"></a>time</em>&nbsp;</td><td class="fielddoc">
<p>IPTC time type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca98944819f3c9921109af5f0a39fcfa34"></a>comment</em>&nbsp;</td><td class="fielddoc">
<p>Exiv2 type for the Exif user comment. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450cafc7cbf89ae7c64de808dc3611b2a880f"></a>directory</em>&nbsp;</td><td class="fielddoc">
<p>Exiv2 type for a CIFF directory. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca77cea60f60ef2c6f0f986137c5404c02"></a>xmpText</em>&nbsp;</td><td class="fielddoc">
<p>XMP text type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca627dda12626324231bb87883d8efc5df"></a>xmpAlt</em>&nbsp;</td><td class="fielddoc">
<p>XMP alternative type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450caa5e7700549d4b079db70605d945447af"></a>xmpBag</em>&nbsp;</td><td class="fielddoc">
<p>XMP bag type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca969c20e44455272599e3a273471546e8"></a>xmpSeq</em>&nbsp;</td><td class="fielddoc">
<p>XMP sequence type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca52dce1d022dd8927bc651d2e51dc1bcd"></a>langAlt</em>&nbsp;</td><td class="fielddoc">
<p>XMP language alternative type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450cafc75de7290b703a810102c8a003fc25e"></a>invalidTypeId</em>&nbsp;</td><td class="fielddoc">
<p>Invalid type id. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5153319711f35fe81cbc13f4b852450ca1d087498b678aa18f77ab6b5c1812921"></a>lastTypeId</em>&nbsp;</td><td class="fielddoc">
<p>Last type id. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a41c00f4c281884b7e6adcb32fbf6789b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API int Exiv2::base64encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>resultSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes in base64 the data in data_buf and puts the resulting string in result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultSize</td><td>size in bytes of the out string, it should be at least ((dataLength + 2) / 3) * 4 + 1 </td></tr>
    <tr><td class="paramname">dataLength</td><td>size in bytes of the in buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string containing the encoded data, or NULL in case of error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>From <a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64">http://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17b52d6f278c7d098731d0a1d7aa4296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Exiv2::cmpIptcdataByRecord </td>
          <td>(</td>
          <td class="paramtype">const Iptcdatum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iptcdatum &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two iptc items by record. Return true if the record of lhs is less than that of rhs. </p>
<p>This is a helper function for <a class="el" href="classExiv2_1_1IptcParser.html#ade6b61bc6ce95b24c2c0b47575f1c20a" title="Encode the IPTC datasets from iptcData to a binary representation in IPTC IIM4 format. ">IptcParser::encode()</a>. </p>

<p>References <a class="el" href="classExiv2_1_1Iptcdatum.html#ae0c9a888c38f17689e14b38baef0fe9b">Exiv2::Iptcdatum::record()</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1IptcParser.html#ade6b61bc6ce95b24c2c0b47575f1c20a">Exiv2::IptcParser::encode()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa666fe01fbcfa969b3e2c648bcf9ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API bool Exiv2::convertStringCharset </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert character encoding of <em>str</em> from <em>from</em> to <em>to</em>. If the function succeeds, <em>str</em> contains the result string. </p>
<p>This function uses the iconv library, if the Exiv2 library was compiled with iconv support. Otherwise, on Windows, it uses Windows functions to support a limited number of conversions and fails with a warning if an unsupported conversion is attempted. If the function is called but Exiv2 was not compiled with iconv support and can't use Windows functions, it fails with a warning.</p>
<p>The conversions supported on Windows without iconv are:</p>
<table class="doxtable">
<tr>
<td class="indexkey"><b>from</b></td><td class="indexkey">to </td></tr>
<tr>
<td class="indexvalue">UTF-8 </td><td class="indexvalue">UCS-2BE </td></tr>
<tr>
<td class="indexvalue">UTF-8 </td><td class="indexvalue">UCS-2LE </td></tr>
<tr>
<td class="indexvalue">UCS-2BE </td><td class="indexvalue">UTF-8 </td></tr>
<tr>
<td class="indexvalue">UCS-2BE </td><td class="indexvalue">UCS-2LE </td></tr>
<tr>
<td class="indexvalue">UCS-2LE </td><td class="indexvalue">UTF-8 </td></tr>
<tr>
<td class="indexvalue">UCS-2LE </td><td class="indexvalue">UCS-2BE </td></tr>
<tr>
<td class="indexvalue">ISO-8859-1</td><td class="indexvalue">UTF-8 </td></tr>
<tr>
<td class="indexvalue">ASCII </td><td class="indexvalue">UTF-8 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. It is updated to the converted string, which may have a different size. If the function call fails, the string is not modified. </td></tr>
    <tr><td class="paramname">from</td><td>Charset in which the input string is encoded as a name understood by <code>iconv_open(3)</code>. </td></tr>
    <tr><td class="paramname">to</td><td>Charset to convert the string to as a name understood by <code>iconv_open(3)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <code>true</code> if the conversion was successful, else <code>false</code>. </dd></dl>

<p>References <a class="el" href="error_8hpp.html#a06ee301360765662f07d822ea005647e">EXV_WARNING</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1Converter.html#a214d53f25cf6cedc9e5b18dde9251346">Exiv2::Converter::cnvIptcValue()</a>, <a class="el" href="classExiv2_1_1CommentValue.html#ae8ccc714149ff42cc6e7993fc8177ed9">Exiv2::CommentValue::comment()</a>, <a class="el" href="classExiv2_1_1AsfVideo.html#aa58d1be6292d01d52f460ba3f2973e62">Exiv2::AsfVideo::contentDescription()</a>, <a class="el" href="classExiv2_1_1CommentValue.html#a1318730b8a15f2f043b1d99390092181">Exiv2::CommentValue::copy()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a0a2a3db205807282b11a0b735737ca4d">Exiv2::Internal::printUcs2()</a>, and <a class="el" href="classExiv2_1_1CommentValue.html#a0dc1a2489912d18b05ba25881ed172c3">Exiv2::CommentValue::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a0432df7d3995fa4d2fbc0b3f90265c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API bool Exiv2::fileExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ct</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a file exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Name of file to verify. </td></tr>
    <tr><td class="paramname">ct</td><td>Flag to check if <em>path</em> is a regular file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>path</em> exists and, if <em>ct</em> is set, is a regular file, else false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function calls <b>stat()</b> test for <em>path</em> and its type, see stat(2). <b>errno</b> is left unchanged in case of an error. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a8fafba026ab8971599f2c2dc7bb4072f">fileProtocol()</a>.</p>

<p>Referenced by <a class="el" href="classAction_1_1Insert.html#af7540acf510da9bddf1fda7481efadb7">Action::Insert::insertThumbnail()</a>, <a class="el" href="classAction_1_1Insert.html#aa11ea4476cec1a900e86ee63111ec919">Action::Insert::insertXmpPacket()</a>, <a class="el" href="classAction_1_1Print.html#a05cf9ae1ba5de0d592f1e4bfea4d5e40">Action::Print::printComment()</a>, <a class="el" href="classAction_1_1Print.html#a8ff7b158d0af021b17484872378856db">Action::Print::printList()</a>, <a class="el" href="classAction_1_1Print.html#a9535c2bb898017531c7c85e6df5db96a">Action::Print::printPreviewList()</a>, <a class="el" href="classAction_1_1Print.html#ae75e2afef18405123890fd58be3b90aa">Action::Print::printSummary()</a>, <a class="el" href="classAction_1_1Rename.html#ab2b811ad1f5ae80e882b9b2b903dbfbb">Action::Rename::run()</a>, <a class="el" href="classAction_1_1Adjust.html#a790b327a3dc85d91fddf2684bd93130e">Action::Adjust::run()</a>, <a class="el" href="classAction_1_1Erase.html#a958425244c6b3eba57d6d229b6eebf99">Action::Erase::run()</a>, <a class="el" href="classAction_1_1Insert.html#a19b222d0125abbcaef71a9797940f40f">Action::Insert::run()</a>, <a class="el" href="classAction_1_1Modify.html#aac2ae1f0a022ea315e722d406374231f">Action::Modify::run()</a>, <a class="el" href="classAction_1_1FixIso.html#a31127eb0657747906d338772b09edd81">Action::FixIso::run()</a>, <a class="el" href="classAction_1_1FixCom.html#a7830e2b278b1a356ccb6ccd82a8a7b2b">Action::FixCom::run()</a>, <a class="el" href="classExiv2_1_1FileIo.html#a7820fe3bdac99ff4a78dccccba1eed10">Exiv2::FileIo::transfer()</a>, <a class="el" href="classAction_1_1Extract.html#aaad8e01ae2d18aa6d67eb68b201f7321">Action::Extract::writePreviews()</a>, and <a class="el" href="classAction_1_1Extract.html#adb8ff97d1933f2dcab9fd6457cca6d03">Action::Extract::writeThumbnail()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fafba026ab8971599f2c2dc7bb4072f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API <a class="el" href="namespaceExiv2.html#a26b6aada6dabfccfc0e99559feb91887">Protocol</a> Exiv2::fileProtocol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the protocol of the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path of file to detect the protocol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the protocol of the path </dd></dl>

<p>Referenced by <a class="el" href="classExiv2_1_1ImageFactory.html#acce2152e7215854736f0902c51e9d247">Exiv2::ImageFactory::createIo()</a>, <a class="el" href="namespaceUtil.html#a2d5eb823f2910e392a04c146c54f9543">Util::dirname()</a>, and <a class="el" href="namespaceExiv2.html#a0432df7d3995fa4d2fbc0b3f90265c59">fileExists()</a>.</p>

</div>
</div>
<a class="anchor" id="aea35ee7a596e1d47d1ffbb553cfb688d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* Exiv2::find </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>src</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an element that matches <em>key</em> in the array <em>src</em>. </p>
<p>Designed to be used with lookup tables as shown in the example below. Requires a Key structure (ideally in the array) and a comparison operator to compare a key with an array element. The size of the array is determined automagically. Thanks to Stephan Broennimann for this nifty implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Bar {</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">int</span> k;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* data;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>Key;</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceExiv2_1_1Internal.html#aea3ff9e44495fcbbbdfd56e8a8b5dd42" title="Compare tag details with a lens entry. ">operator==</a>(<span class="keyword">const</span> Bar::Key&amp; rhs) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Bar::Key {</div>
<div class="line">    Key(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : i(a), k(b) {}</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">int</span> k;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Bar::operator==(<span class="keyword">const</span> Bar::Key&amp; key) <span class="keyword">const</span> <span class="comment">// definition</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> i == key.i &amp;&amp; k == key.k;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> Bar bars[] = {</div>
<div class="line">    { 1, 1, <span class="stringliteral">&quot;bar data 1&quot;</span> },</div>
<div class="line">    { 1, 2, <span class="stringliteral">&quot;bar data 2&quot;</span> },</div>
<div class="line">    { 1, 3, <span class="stringliteral">&quot;bar data 3&quot;</span> }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <span class="keyword">const</span> Bar* bar = <a class="code" href="namespaceExiv2.html#aea35ee7a596e1d47d1ffbb553cfb688d" title="Find an element that matches key in the array src. ">find</a>(bars, Bar::Key(1, 3));</div>
<div class="line">    <span class="keywordflow">if</span> (bar) std::cout &lt;&lt; bar-&gt;data &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;Key not found.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classExiv2_1_1ImageFactory.html#a2953661dfbe37cf916e4fdeb5ef5c519">Exiv2::ImageFactory::checkMode()</a>, <a class="el" href="classExiv2_1_1ImageFactory.html#af9aa6dad41f17eb012d8d18e291d19f9">Exiv2::ImageFactory::checkType()</a>, <a class="el" href="classExiv2_1_1AsfVideo.html#aa58d1be6292d01d52f460ba3f2973e62">Exiv2::AsfVideo::contentDescription()</a>, <a class="el" href="classExiv2_1_1MatroskaVideo.html#a4f6303ad384986bc092513d4f82d26be">Exiv2::MatroskaVideo::contentManagement()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffMnCreator.html#a1320c47f78af761d8851a4d3607bbbe1">Exiv2::Internal::TiffMnCreator::create()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffCreator.html#ae9fc1e9bb38355358e114a982afafcbb">Exiv2::Internal::TiffCreator::create()</a>, <a class="el" href="classExiv2_1_1ImageFactory.html#a047254c8b06726cc0c3733e066a0bc97">Exiv2::ImageFactory::create()</a>, <a class="el" href="classExiv2_1_1AsfVideo.html#ab2b7a6f061b76dac6ce80f3c4de016fd">Exiv2::AsfVideo::decodeBlock()</a>, <a class="el" href="classExiv2_1_1MatroskaVideo.html#a84bbfe45f7ce0bb1b78b28346a3262ca">Exiv2::MatroskaVideo::decodeBlock()</a>, <a class="el" href="namespaceExiv2.html#a91ac628011b2304dd3c6fa65e7b52051">errMsg()</a>, <a class="el" href="classExiv2_1_1AsfVideo.html#af240b3ac1ad8234e3fa4d3f24a3770b2">Exiv2::AsfVideo::fileProperties()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffMapping.html#a03f4d94b3e5dcad752ce88e228bb5c2d">Exiv2::Internal::TiffMapping::findDecoder()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffMapping.html#af1929701af5886a4768883d577e96a1c">Exiv2::Internal::TiffMapping::findEncoder()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffCreator.html#a47e495da6bbd360c753372890192139c">Exiv2::Internal::TiffCreator::getPath()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a8d40d5f0bced57d0a6564f7d5bfe9494">Exiv2::Internal::groupId()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a02590bedabb5438d17b309363cc9ff2f">Exiv2::Internal::groupName()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a6a14670f47e8b636f0d0e24913638a6f">Exiv2::Internal::ifdName()</a>, <a class="el" href="classExiv2_1_1RiffVideo.html#ae020c8e690366d44e6df026ef0546647">Exiv2::RiffVideo::infoTagsHandler()</a>, <a class="el" href="classExiv2_1_1Internal_1_1TiffHeader.html#a5351189136b42536bb9d052a16f21ddc">Exiv2::Internal::TiffHeader::isImageTag()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a080ea8768c028af335952d166ef3e2e9">Exiv2::Internal::isMakerIfd()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#ada054fe3aa5471a1c547503754778613">Exiv2::Internal::isTiffImageTag()</a>, <a class="el" href="classExiv2_1_1TiffImage.html#ac756bdc09ffb0ab6acf005058b2ac032">Exiv2::TiffImage::mimeType()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a793f2472ec54d909cd6032d01fd21dae">Exiv2::Internal::nikonCrypt()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a0f2631eb24935814c8f3740cf459de4b">Exiv2::Internal::nikonSelector()</a>, <a class="el" href="classExiv2_1_1RiffVideo.html#a541245537e624c8f281766c4ecbed1a0">Exiv2::RiffVideo::nikonTagsHandler()</a>, <a class="el" href="classExiv2_1_1Internal_1_1Nikon3MakerNote.html#a6346ff8bb13bdb6081c653b203029d16">Exiv2::Internal::Nikon3MakerNote::print0x009e()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a2d2801b3721349edfac2256fc972ae27">Exiv2::Internal::printCombiTag()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a44720406696b4212b31d6e5550e4f2ca">Exiv2::Internal::printCsLensByFocalLengthAndMaxAperture()</a>, <a class="el" href="classExiv2_1_1Internal_1_1CanonMakerNote.html#abe617b7dc5018aa2aecdcfd7aec32035">Exiv2::Internal::CanonMakerNote::printCsLensType()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#aeeed3e68dbb466e97978cb74f0b34e3e">Exiv2::Internal::printTag()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a7f50cfce460d4cbc48d20115d685e666">Exiv2::Internal::printTagVocabulary()</a>, <a class="el" href="classExiv2_1_1RiffVideo.html#a157a30b3aacd4da9ab6f5ce60328b48d">Exiv2::RiffVideo::streamFormatHandler()</a>, <a class="el" href="classExiv2_1_1AsfVideo.html#aca3525cac4bcfe1e26267cf5974b24f5">Exiv2::AsfVideo::streamProperties()</a>, <a class="el" href="classExiv2_1_1ExifTags.html#ab8daef767ee7ec0d126b46b3b9104536">Exiv2::ExifTags::tagList()</a>, <a class="el" href="namespaceExiv2_1_1Internal.html#a5173c535856e05763c719329f89c843c">Exiv2::Internal::tagList()</a>, <a class="el" href="classExiv2_1_1TypeInfo.html#a01bebc7e74dbe0de31301f9335f03f00">Exiv2::TypeInfo::typeId()</a>, <a class="el" href="classExiv2_1_1TypeInfo.html#a774ccbf72e5a93ff104d27cf9969b095">Exiv2::TypeInfo::typeName()</a>, <a class="el" href="classExiv2_1_1TypeInfo.html#abda613af50ccdddcad9a7bb75fcb2338">Exiv2::TypeInfo::typeSize()</a>, and <a class="el" href="classExiv2_1_1Internal_1_1TiffReader.html#a893b2e995e622d55268c04fea5f36561">Exiv2::Internal::TiffReader::visitBinaryArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a6caa281728674d5138df8907be61c00e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> Exiv2::floatToRationalCast </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Very simple conversion of a <em>float</em> to a <em>Rational</em>. </p>
<p>Test it with the values that you expect and check the implementation to see if this is really what you want! </p>

<p>References <a class="el" href="namespaceExiv2.html#a36dc44cabbd590c8083ed6eeab81c92d">gcd()</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1Converter.html#ab919aa805d435f5da8119fb5ab7272a3">Exiv2::Converter::cnvXmpGPSCoord()</a>, <a class="el" href="namespaceExiv2.html#ad0c754e9c64ad5daa1f0fc5a32b88e1f">parseRational()</a>, and <a class="el" href="classExiv2_1_1ValueType.html#aed8ff3edec29000ce609e1f756ff7742">Exiv2::ValueType&lt; T &gt;::toRational()</a>.</p>

</div>
</div>
<a class="anchor" id="a36dc44cabbd590c8083ed6eeab81c92d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType Exiv2::gcd </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the greatest common denominator of n and m. (Implementation from Boost rational.hpp) </p>
<dl class="section note"><dt>Note</dt><dd>We use n and m as temporaries in this function, so there is no value in using const IntType&amp; as we would only need to make a copy anyway... </dd></dl>

<p>Referenced by <a class="el" href="namespaceExiv2.html#a6caa281728674d5138df8907be61c00e">floatToRationalCast()</a>, and <a class="el" href="namespaceExiv2_1_1Internal.html#abc26de089a85c0fff7b0f93c0a8c91b6">Exiv2::Internal::print0x9204()</a>.</p>

</div>
</div>
<a class="anchor" id="a4901857878dd5ae68afb2f6d075993fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#aca1645cade15ccc7979d93c5011b1305">getDouble()</a>, <a class="el" href="namespaceExiv2.html#a222c7a2b5ba8f0f195a52231c83fe1eb">getFloat()</a>, <a class="el" href="namespaceExiv2.html#aaaa13407701ef70800058a760e8be52e">getLong()</a>, <a class="el" href="namespaceExiv2.html#a4f99d0bb9a8a2d8ae0b85e2a556325d4">getRational()</a>, <a class="el" href="namespaceExiv2.html#a034a977f27f32a817d6846160f3723c9">getShort()</a>, <a class="el" href="namespaceExiv2.html#a2ac010ed4daa22c05b792ade639cda07">getULong()</a>, <a class="el" href="namespaceExiv2.html#abd349c39a93e397914cef0e8c511d147">getURational()</a>, and <a class="el" href="namespaceExiv2.html#aba0bbd0d82b12d40d7ff78e54b91d9eb">getUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a018b02b6bb14db1f15fdc51d18707166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#aba0bbd0d82b12d40d7ff78e54b91d9eb">getUShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a81c794910171e9fc803354c1840d658d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a2ac010ed4daa22c05b792ade639cda07">getULong()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2d0a94bfc9cfcbf0d7dbc70d6e2d818"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceExiv2.html#aedcaa9af0563cbd00a19b040d5aa7a70">URational</a> Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#abd349c39a93e397914cef0e8c511d147">getURational()</a>.</p>

</div>
</div>
<a class="anchor" id="afecdbbe9c009a5f96a5f85ade05bd28e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a034a977f27f32a817d6846160f3723c9">getShort()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d7355853dc6a1b516eafd9a398c1d5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#aaaa13407701ef70800058a760e8be52e">getLong()</a>.</p>

</div>
</div>
<a class="anchor" id="a119c6400314a13c2f7dd5710adb734a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a4f99d0bb9a8a2d8ae0b85e2a556325d4">getRational()</a>.</p>

</div>
</div>
<a class="anchor" id="af92314aa203ce8a3d30aa52117496dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a222c7a2b5ba8f0f195a52231c83fe1eb">getFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4e9a94996ef8406470309bb4cce9ac4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Exiv2::getValue </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value of type T from the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to read from. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type T. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#aca1645cade15ccc7979d93c5011b1305">getDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a61c3bf069dab26d8a8b945de0b546b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API float Exiv2::parseFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <em>float</em> set to the value represented by <em>s</em>. </p>
<p>Besides strings that represent <em>float</em> values, the function also handles <em>long</em>, <em>Rational</em> and boolean (see also: <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001" title="Utility function to convert a string to a value of type T. ">stringTo(const std::string&amp; s, bool&amp; ok)</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to parse </td></tr>
    <tr><td class="paramname">ok</td><td>Output variable indicating the success of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the <em>float</em> value represented by <em>s</em> and sets <em>ok</em> to <code>true</code> if the conversion was successful or <code>false</code> if not. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a5584318f5a20a6e35420d04d99c60bc3">stringTo&lt; bool &gt;()</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1XmpTextValue.html#a6c2a64ebd906041827b005a6dca1f5ce">Exiv2::XmpTextValue::toFloat()</a>, and <a class="el" href="classExiv2_1_1XmpArrayValue.html#a6ea92652ac312c5fecdb57217176ac3a">Exiv2::XmpArrayValue::toFloat()</a>.</p>

</div>
</div>
<a class="anchor" id="a1409855f9f68490e5d791b1bffc6a708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API long Exiv2::parseLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <em>long</em> set to the value represented by <em>s</em>. </p>
<p>Besides strings that represent <em>long</em> values, the function also handles <em>float</em>, <em>Rational</em> and boolean (see also: <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001" title="Utility function to convert a string to a value of type T. ">stringTo(const std::string&amp; s, bool&amp; ok)</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to parse </td></tr>
    <tr><td class="paramname">ok</td><td>Output variable indicating the success of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the <em>long</em> value represented by <em>s</em> and sets <em>ok</em> to <code>true</code> if the conversion was successful or <code>false</code> if not. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a5584318f5a20a6e35420d04d99c60bc3">stringTo&lt; bool &gt;()</a>.</p>

<p>Referenced by <a class="el" href="namespaceExiv2.html#a8d233d6897570fcd74607c1b545f0039">isoSpeed()</a>, <a class="el" href="classExiv2_1_1XmpTextValue.html#ab84a3e6f634f39deab22f182880fdcdd">Exiv2::XmpTextValue::toLong()</a>, and <a class="el" href="classExiv2_1_1XmpArrayValue.html#a41a3387f5c5697df4033fefbef8b8b1e">Exiv2::XmpArrayValue::toLong()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0c754e9c64ad5daa1f0fc5a32b88e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API <a class="el" href="namespaceExiv2.html#a95756f3f7fa19103f83addf5fa088a30">Rational</a> Exiv2::parseRational </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <em>Rational</em> set to the value represented by <em>s</em>. </p>
<p>Besides strings that represent <em>Rational</em> values, the function also handles <em>long</em>, <em>float</em> and boolean (see also: <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001" title="Utility function to convert a string to a value of type T. ">stringTo(const std::string&amp; s, bool&amp; ok)</a>). Uses <a class="el" href="namespaceExiv2.html#a6caa281728674d5138df8907be61c00e" title="Very simple conversion of a float to a Rational. ">floatToRationalCast(float f)</a> if the string can be parsed into a <em>float</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to parse </td></tr>
    <tr><td class="paramname">ok</td><td>Output variable indicating the success of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the <em>Rational</em> value represented by <em>s</em> and sets <em>ok</em> to <code>true</code> if the conversion was successful or <code>false</code> if not. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a6caa281728674d5138df8907be61c00e">floatToRationalCast()</a>, and <a class="el" href="namespaceExiv2.html#a5584318f5a20a6e35420d04d99c60bc3">stringTo&lt; bool &gt;()</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1XmpTextValue.html#ae1b09db38ddece02c314e6562457efd0">Exiv2::XmpTextValue::toRational()</a>, and <a class="el" href="classExiv2_1_1XmpArrayValue.html#a4f3c3a818f243b039694973a9c2a96c6">Exiv2::XmpArrayValue::toRational()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c87ddedd63e9ab9aa6f295cda32aebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API <a class="el" href="classExiv2_1_1DataBuf.html">DataBuf</a> Exiv2::readFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read file <em>path</em> into a <a class="el" href="classExiv2_1_1DataBuf.html" title="Utility class containing a character array. All it does is to take care of memory allocation and dele...">DataBuf</a>, which is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Buffer containing the file. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Error</td><td>In case of failure. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classExiv2_1_1FileIo.html#a1793ddca7f8c94619ceae7a127da73c2">Exiv2::FileIo::open()</a>, <a class="el" href="classExiv2_1_1DataBuf.html#a9a00173081c913d3add58854d9ad2c39">Exiv2::DataBuf::pData_</a>, <a class="el" href="classExiv2_1_1FileIo.html#a5c7364fbbdc740ec0736da33ad9a82f0">Exiv2::FileIo::read()</a>, <a class="el" href="classExiv2_1_1DataBuf.html#a5e6028d5cdae2e149749667cf66c3e91">Exiv2::DataBuf::size_</a>, and <a class="el" href="namespaceExiv2.html#a086796c27d01f4618a158a0e56905f72">strError()</a>.</p>

<p>Referenced by <a class="el" href="classAction_1_1Insert.html#aa11ea4476cec1a900e86ee63111ec919">Action::Insert::insertXmpPacket()</a>, and <a class="el" href="classExiv2_1_1ExifThumb.html#a90e5155ba60dae3af4066f80464c788d">Exiv2::ExifThumb::setJpegThumbnail()</a>.</p>

</div>
</div>
<a class="anchor" id="a548778abb2cec5c7cfc18d38355c0a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API std::string Exiv2::ReplaceStringInPlace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replace each substring of the subject that matches the given search string with the given replacement. </p>
<dl class="section return"><dt>Returns</dt><dd>the subject after replacing. </dd></dl>

<p>Referenced by <a class="el" href="classExiv2_1_1StdinIo.html#a1a539983484c7f53d8a05297509c99d0">Exiv2::StdinIo::transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1576dd000687193c9ebbb672eb7164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExiv2_1_1Exifdatum.html">Exiv2::Exifdatum</a>&amp; Exiv2::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classExiv2_1_1Exifdatum.html">Exiv2::Exifdatum</a> &amp;&#160;</td>
          <td class="paramname"><em>exifDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of <em>exifDatum</em> to <em>value</em>. If the object already has a value, it is replaced. Otherwise a new <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a>&lt;T&gt; value is created and set to <em>value</em>. </p>
<p>This is a helper function, called from <a class="el" href="classExiv2_1_1Exifdatum.html" title="An Exif metadatum, consisting of an ExifKey and a Value and methods to manipulate these...">Exifdatum</a> members. It is meant to be used with T = (u)int16_t, (u)int32_t or (U)Rational. Do not use directly. </p>

<p>Referenced by <a class="el" href="classExiv2_1_1Exifdatum.html#ad29bb9ce35e4b7be8ea67d26738bed65">Exiv2::Exifdatum::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a94f8949fc0e956f239c26489e87c7001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Exiv2::stringTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to convert a string to a value of type <code>T</code>. </p>
<p>The string representation of the value must match that recognized by the input operator for <code>T</code> for this function to succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to convert </td></tr>
    <tr><td class="paramname">ok</td><td>Output variable indicating the success of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the converted value and sets <em>ok</em> to <code>true</code> if the conversion was successful or <code>false</code> if not. </dd></dl>

<p>References <a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca2d79fb07c9ec891f281968dad43c1e25">string</a>.</p>

</div>
</div>
<a class="anchor" id="a5584318f5a20a6e35420d04d99c60bc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001">Exiv2::stringTo</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="namespaceExiv2.html#a94f8949fc0e956f239c26489e87c7001" title="Utility function to convert a string to a value of type T. ">stringTo(const std::string&amp; s, bool&amp; ok)</a> for <em>bool</em>. </p>
<p>Handles the same string values as the XMP SDK. Converts the string to lowercase and returns <code>true</code> if it is "true", "t" or "1", and <code>false</code> if it is "false", "f" or "0". </p>

<p>References <a class="el" href="namespaceExiv2.html#a5153319711f35fe81cbc13f4b852450ca2d79fb07c9ec891f281968dad43c1e25">string</a>.</p>

<p>Referenced by <a class="el" href="namespaceExiv2.html#a61c3bf069dab26d8a8b945de0b546b27">parseFloat()</a>, <a class="el" href="namespaceExiv2.html#a1409855f9f68490e5d791b1bffc6a708">parseLong()</a>, and <a class="el" href="namespaceExiv2.html#ad0c754e9c64ad5daa1f0fc5a32b88e1f">parseRational()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d8f92acdf4d23b673225584405fba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API bool Exiv2::testVersion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the version of the available Exiv2 library at runtime. Return true if it is the same as or newer than the passed-in version. </p>
<p>Versions are denoted using a triplet of integers: <em>major.minor.patch</em> .</p>
<div class="fragment"><div class="line"><span class="comment">// Don&#39;t include the &lt;exiv2/version.hpp&gt; file directly, it is included by</span></div>
<div class="line"><span class="comment">// &lt;exiv2/types.hpp&gt;. Early Exiv2 versions didn&#39;t have version.hpp and the macros.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="types_8hpp.html" title="Type definitions for Exiv2 and related functionality. ">exiv2/types.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Make sure an EXIV2_TEST_VERSION macro exists:</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef EXIV2_VERSION</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># ifndef EXIV2_TEST_VERSION</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># define EXIV2_TEST_VERSION(major,minor,patch) \</span></div>
<div class="line"><span class="preprocessor">    ( EXIV2_VERSION &gt;= EXIV2_MAKE_VERSION(major,minor,patch) )</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor"># define EXIV2_TEST_VERSION(major,minor,patch) (false)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Compiled with Exiv2 version &quot;</span> &lt;&lt; EXV_PACKAGE_VERSION &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;Runtime Exiv2 version is    &quot;</span> &lt;&lt; <a class="code" href="namespaceExiv2.html#a8bc2141c839d15abc9f1473e8cc701fd" title="Return the version of Exiv2 available at runtime as a string. ">Exiv2::version</a>()    &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Test the Exiv2 version available at runtime but compile the if-clause only if</span></div>
<div class="line"><span class="comment">// the compile-time version is at least 0.15. Earlier versions didn&#39;t have a</span></div>
<div class="line"><span class="comment">// testVersion() function:</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if EXIV2_TEST_VERSION(0,15,0)</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordflow">if</span> (<a class="code" href="namespaceExiv2.html#ad8d8f92acdf4d23b673225584405fba5" title="Test the version of the available Exiv2 library at runtime. Return true if it is the same as or newer...">Exiv2::testVersion</a>(0,13,0)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Available Exiv2 version is equal to or greater than 0.13\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Installed Exiv2 version is less than 0.13\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>std::cout &lt;&lt; <span class="stringliteral">&quot;Compile-time Exiv2 version doesn&#39;t have Exiv2::testVersion()\n&quot;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> 
<p>References <a class="el" href="version_8hpp.html#a5d75ce8591ccba90183669df83a9b436">EXIV2_MAKE_VERSION</a>, and <a class="el" href="namespaceExiv2.html#add349cd7b6bc3b9566d00f8d41c08fe3">versionNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a59acfb133eebbee93865f1cc07106bca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long Exiv2::toData </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteOrder&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a value of type T to data, write the data to the data buffer. </p>
<p>We need this template function for the <a class="el" href="classExiv2_1_1ValueType.html" title="Template for a Value of a basic type. This is used for unsigned and signed short, long and rationals...">ValueType</a> template classes. There are only specializations of this function available; no default implementation is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data buffer to write to. </td></tr>
    <tr><td class="paramname">t</td><td><a class="el" href="classExiv2_1_1Value.html" title="Common interface for all types of values used with metadata. ">Value</a> to be converted. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>Applicable byte order (little or big endian). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the buffer. </dd></dl>

<p>Referenced by <a class="el" href="classExiv2_1_1ValueType.html#a106239c4587a27ce53b6a59b63d7b348">Exiv2::ValueType&lt; T &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a65c0189894e7563da9a932e9c826e761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXIV2API long Exiv2::writeFile </td>
          <td>(</td>
          <td class="paramtype">const DataBuf &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write <a class="el" href="classExiv2_1_1DataBuf.html" title="Utility class containing a character array. All it does is to take care of memory allocation and dele...">DataBuf</a> <em>buf</em> to file <em>path</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes written. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Error</td><td>In case of failure. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classExiv2_1_1FileIo.html#a1793ddca7f8c94619ceae7a127da73c2">Exiv2::FileIo::open()</a>, <a class="el" href="classExiv2_1_1DataBuf.html#a9a00173081c913d3add58854d9ad2c39">Exiv2::DataBuf::pData_</a>, <a class="el" href="classExiv2_1_1DataBuf.html#a5e6028d5cdae2e149749667cf66c3e91">Exiv2::DataBuf::size_</a>, <a class="el" href="namespaceExiv2.html#a086796c27d01f4618a158a0e56905f72">strError()</a>, and <a class="el" href="classExiv2_1_1FileIo.html#a5b3d5f5a5b4b7f9d3d8cec46a4ad95f7">Exiv2::FileIo::write()</a>.</p>

<p>Referenced by <a class="el" href="classExiv2_1_1PreviewImage.html#acb74c09c1a6d44565bfeb8ef8a5134e0">Exiv2::PreviewImage::writeFile()</a>, and <a class="el" href="classExiv2_1_1ExifThumbC.html#a28a632e5ca0be46d1348aec33d77d1ae">Exiv2::ExifThumbC::writeFile()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="adda2ec7f698d8dbf322a6152945682ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structExiv2_1_1MimeTypeList.html">MimeTypeList</a> Exiv2::mimeTypeList[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        { 32770, <span class="stringliteral">&quot;image/x-samsung-srw&quot;</span> },</div>
<div class="line">        { 34713, <span class="stringliteral">&quot;image/x-nikon-nef&quot;</span>   },</div>
<div class="line">        { 65535, <span class="stringliteral">&quot;image/x-pentax-pef&quot;</span>  }</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>List of TIFF compression to MIME type mappings. </p>

<p>Referenced by <a class="el" href="classExiv2_1_1TiffImage.html#ac756bdc09ffb0ab6acf005058b2ac032">Exiv2::TiffImage::mimeType()</a>.</p>

</div>
</div>
<a class="anchor" id="af4879bfd704a610f3fe65e1476df6609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExiv2_1_1Internal_1_1SectionInfo.html">SectionInfo</a> Exiv2::sectionInfo[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        { sectionIdNotSet, <span class="stringliteral">&quot;(UnknownSection)&quot;</span>,     N_(<span class="stringliteral">&quot;Unknown section&quot;</span>)              },</div>
<div class="line">        { imgStruct,       <span class="stringliteral">&quot;ImageStructure&quot;</span>,       N_(<span class="stringliteral">&quot;Image data structure&quot;</span>)         },</div>
<div class="line">        { recOffset,       <span class="stringliteral">&quot;RecordingOffset&quot;</span>,      N_(<span class="stringliteral">&quot;Recording offset&quot;</span>)             },</div>
<div class="line">        { imgCharacter,    <span class="stringliteral">&quot;ImageCharacteristics&quot;</span>, N_(<span class="stringliteral">&quot;Image data characteristics&quot;</span>)   },</div>
<div class="line">        { otherTags,       <span class="stringliteral">&quot;OtherTags&quot;</span>,            N_(<span class="stringliteral">&quot;Other data&quot;</span>)                   },</div>
<div class="line">        { exifFormat,      <span class="stringliteral">&quot;ExifFormat&quot;</span>,           N_(<span class="stringliteral">&quot;Exif data structure&quot;</span>)          },</div>
<div class="line">        { exifVersion,     <span class="stringliteral">&quot;ExifVersion&quot;</span>,          N_(<span class="stringliteral">&quot;Exif version&quot;</span>)                 },</div>
<div class="line">        { imgConfig,       <span class="stringliteral">&quot;ImageConfig&quot;</span>,          N_(<span class="stringliteral">&quot;Image configuration&quot;</span>)          },</div>
<div class="line">        { userInfo,        <span class="stringliteral">&quot;UserInfo&quot;</span>,             N_(<span class="stringliteral">&quot;User information&quot;</span>)             },</div>
<div class="line">        { relatedFile,     <span class="stringliteral">&quot;RelatedFile&quot;</span>,          N_(<span class="stringliteral">&quot;Related file&quot;</span>)                 },</div>
<div class="line">        { dateTime,        <span class="stringliteral">&quot;DateTime&quot;</span>,             N_(<span class="stringliteral">&quot;Date and time&quot;</span>)                },</div>
<div class="line">        { captureCond,     <span class="stringliteral">&quot;CaptureConditions&quot;</span>,    N_(<span class="stringliteral">&quot;Picture taking conditions&quot;</span>)    },</div>
<div class="line">        { gpsTags,         <span class="stringliteral">&quot;GPS&quot;</span>,                  N_(<span class="stringliteral">&quot;GPS information&quot;</span>)              },</div>
<div class="line">        { iopTags,         <span class="stringliteral">&quot;Interoperability&quot;</span>,     N_(<span class="stringliteral">&quot;Interoperability information&quot;</span>) },</div>
<div class="line">        { makerTags,       <span class="stringliteral">&quot;Makernote&quot;</span>,            N_(<span class="stringliteral">&quot;Vendor specific information&quot;</span>)  },</div>
<div class="line">        { dngTags,         <span class="stringliteral">&quot;DngTags&quot;</span>,              N_(<span class="stringliteral">&quot;Adobe DNG tags&quot;</span>)               },</div>
<div class="line">        { panaRaw,         <span class="stringliteral">&quot;PanasonicRaw&quot;</span>,         N_(<span class="stringliteral">&quot;Panasonic RAW tags&quot;</span>)           },</div>
<div class="line">        { tiffEp,          <span class="stringliteral">&quot;TIFF/EP&quot;</span>,              N_(<span class="stringliteral">&quot;TIFF/EP tags&quot;</span>)                 },</div>
<div class="line">        { tiffPm6,         <span class="stringliteral">&quot;TIFF&amp;PM6&quot;</span>,             N_(<span class="stringliteral">&quot;TIFF PageMaker 6.0 tags&quot;</span>)      },</div>
<div class="line">        { adobeOpi,        <span class="stringliteral">&quot;AdobeOPI&quot;</span>,             N_(<span class="stringliteral">&quot;Adobe OPI tags&quot;</span>)               },</div>
<div class="line">        { lastSectionId,   <span class="stringliteral">&quot;(LastSection)&quot;</span>,        N_(<span class="stringliteral">&quot;Last section&quot;</span>)                 }</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>List of all defined Exif sections. </p>

<p>Referenced by <a class="el" href="classExiv2_1_1ExifTags.html#ab1f99d9f94c3953e0dd29da28cf2df0b">Exiv2::ExifTags::sectionName()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 19 2013 05:27:38 for Exiv2 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
