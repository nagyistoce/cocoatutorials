.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mac::Finder::DSStore::BuddyAllocator 3"
.TH Mac::Finder::DSStore::BuddyAllocator 3 "2010-05-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Finder::DSStore::BuddyAllocator \- Allocate space within a file
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mac::Finder::DSStore::BuddyAllocator\*(C'\fR
implements a buddy-allocation scheme within a file. It's used by
\&\f(CW\*(C`Mac::Finder::DSStore\*(C'\fR to read certain files created by the Macintosh
Finder.
.PP
The allocation methods do not perform any actual file I/O.
The contents of allocated blocks are read and written by the caller using
methods on \f(CW\*(C`BuddyAllocator::Block\*(C'\fR.
If the \f(CW\*(C`allocate\*(C'\fR and \f(CW\*(C`free\*(C'\fR methods are used,
or if the \f(CW\*(C`toc\*(C'\fR hash is modified,
\&\f(CW\*(C`writeMetaData\*(C'\fR must be called for the changes to be reflected in the file.
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh "$allocator = Mac::Finder::DSStore::BuddyAllocator\->open($fh)"
.el .Sh "\f(CW$allocator\fP = Mac::Finder::DSStore::BuddyAllocator\->open($fh)"
.IX Subsection "$allocator = Mac::Finder::DSStore::BuddyAllocator->open($fh)"
\&\f(CW\*(C`open($fh)\*(C'\fR constructs a new buddy allocator 
and initializes its state from the information in the file.
The file handle is retained by the allocator for future
operations.
.ie n .Sh "$allocator = Mac::Finder::DSStore::BuddyAllocator\->new($fh)"
.el .Sh "\f(CW$allocator\fP = Mac::Finder::DSStore::BuddyAllocator\->new($fh)"
.IX Subsection "$allocator = Mac::Finder::DSStore::BuddyAllocator->new($fh)"
Similar to \f(CW\*(C`open\*(C'\fR, but does not read anything from the file. This
can be used to create a new file from scratch.
.ie n .Sh "$allocator\->close( )"
.el .Sh "\f(CW$allocator\fP\->close( )"
.IX Subsection "$allocator->close( )"
Closes the underlying file handle.
.ie n .Sh "$allocator\->listBlocks($verbose)"
.el .Sh "\f(CW$allocator\fP\->listBlocks($verbose)"
.IX Subsection "$allocator->listBlocks($verbose)"
List all the blocks in order and see if there are any gaps or overlaps.
If \f(CW$verbose\fR is true, then the blocks are listed to the current
output filehandle. Returns true if the allocated and free blocks
have no gaps or overlaps.
.ie n .Sh "$allocator\->writeMetaData( )"
.el .Sh "\f(CW$allocator\fP\->writeMetaData( )"
.IX Subsection "$allocator->writeMetaData( )"
Writes the allocator's metadata (header block and root block)
back to the file.
.ie n .Sh "$block\fP = \f(CW$allocator\->blockByNumber(blocknumber[, write])"
.el .Sh "\f(CW$block\fP = \f(CW$allocator\fP\->blockByNumber(blocknumber[, write])"
.IX Subsection "$block = $allocator->blockByNumber(blocknumber[, write])"
Retrieves a block by its block number (\fIaka\fR block \s-1ID\s0).
.PP
If \f(CW\*(C`write\*(C'\fR is supplied and is true, then the returned block implements the
\&\f(CW\*(C`write\*(C'\fR method but not the \f(CW\*(C`read\*(C'\fR method.
.ie n .Sh "$block\fP = \f(CW$allocator\->getBlock(offset, size)"
.el .Sh "\f(CW$block\fP = \f(CW$allocator\fP\->getBlock(offset, size)"
.IX Subsection "$block = $allocator->getBlock(offset, size)"
Retrieves a block (a BuddyAllocator::Block instance) by offset & length.
Normally you should use \f(CW\*(C`blockByNumber\*(C'\fR instead of this method.
.ie n .Sh "( $offset\fP, \f(CW$size\fP ) = \f(CW$allocator\->blockOffset(blockid)"
.el .Sh "( \f(CW$offset\fP, \f(CW$size\fP ) = \f(CW$allocator\fP\->blockOffset(blockid)"
.IX Subsection "( $offset, $size ) = $allocator->blockOffset(blockid)"
Retrieves the file offset and size in bytes of a given block.
The offset doesn't include the 4\-byte fudge.
In scalar context, just returns the offset.
.ie n .Sh "$blocknumber\fP = \f(CW$allocator\->allocate($size, [$blocknumber])"
.el .Sh "\f(CW$blocknumber\fP = \f(CW$allocator\fP\->allocate($size, [$blocknumber])"
.IX Subsection "$blocknumber = $allocator->allocate($size, [$blocknumber])"
Allocates or re-allocates a block to be at least \f(CW$size\fR bytes long.
If \f(CW$blocknumber\fR is given, the specified block will be grown or
shrunk if needed, otherwise a new block number will be chosen and
given to the allocated block.
.PP
Unlike the libc \f(CW\*(C`realloc\*(C'\fR function, this may move a block even if the
block is not grown.
.ie n .Sh "$allocator\->free($blocknumer)"
.el .Sh "\f(CW$allocator\fP\->free($blocknumer)"
.IX Subsection "$allocator->free($blocknumer)"
Releases the block number and the block associated with it back to the
block pool.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.ie n .Sh "$allocator\->{toc}"
.el .Sh "\f(CW$allocator\fP\->{toc}"
.IX Subsection "$allocator->{toc}"
\&\f(CW\*(C`toc\*(C'\fR holds a hashref whose keys are short strings and whose values
are integers. This table of contents is read and written as part of the
allocator's metadata but is not otherwise used by the allocator;
users of the allocator use it to find their data within the file.
.ie n .Sh "$allocator\->{fh}"
.el .Sh "\f(CW$allocator\fP\->{fh}"
.IX Subsection "$allocator->{fh}"
The file handle passed in to \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`new\*(C'\fR. If you find yourself needing
to use this, you should probably try to extend the class so that you don't.
.SH "BuddyAllocator::Block"
.IX Header "BuddyAllocator::Block"
\&\f(CW\*(C`BuddyAllocator::Block\*(C'\fR instances are returned by the
\&\f(CW\*(C`blockByNumber\*(C'\fR and \f(CW\*(C`getBlock\*(C'\fR methods. They hold a pointer into
the file and provide a handful of useful methods.
.PP
(There are also two other classes, \f(CW\*(C`WriteBlock\*(C'\fR and \f(CW\*(C`StringBlock\*(C'\fR,
which might be returned instead. Think of this as an interface rather
than as a concrete class.)
.ie n .Sh "$block\->read(length, [format])"
.el .Sh "\f(CW$block\fP\->read(length, [format])"
.IX Subsection "$block->read(length, [format])"
Reads \f(CW\*(C`length\*(C'\fR bytes from the block (advancing the read pointer
correspondingly). If \f(CW\*(C`format\*(C'\fR is specified, the bytes read are
unpacked using the format; otherwise a byte string is returned.
.ie n .Sh "$block\->length( )"
.el .Sh "\f(CW$block\fP\->length( )"
.IX Subsection "$block->length( )"
Returns the length (or size) of this block.
.ie n .Sh "$block\->seek(position[, whence])"
.el .Sh "\f(CW$block\fP\->seek(position[, whence])"
.IX Subsection "$block->seek(position[, whence])"
Adjusts the read/write pointer within the block.
.ie n .Sh "$block\->write(bytes)"
.el .Sh "\f(CW$block\fP\->write(bytes)"
.IX Subsection "$block->write(bytes)"
.ie n .Sh "$block\->write(format, items...)"
.el .Sh "\f(CW$block\fP\->write(format, items...)"
.IX Subsection "$block->write(format, items...)"
Writes data to the underlying file, at the position represented by this
block. If multiple arguments are given, the first is a format string
and the rest are the remaining arguments to \f(CW\*(C`pack\*(C'\fR.
.ie n .Sh "$block\->close([ zerofill ])"
.el .Sh "\f(CW$block\fP\->close([ zerofill ])"
.IX Subsection "$block->close([ zerofill ])"
This is generally a no-op, but if called on a writable block with
\&\f(CW\*(C`zerofill = true\*(C'\fR, then zeroes will be written from the current
location to the end of the allocated block.
.ie n .Sh "$block\->copyback( )"
.el .Sh "\f(CW$block\fP\->copyback( )"
.IX Subsection "$block->copyback( )"
Returns the block's contents as a string. For write blocks, this
reads from the file. This is just here for debugging purposes and
might change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Wim Lewis as part of the Mac::Finder::DSStore package.
.PP
This file is copyright 2008 by Wim Lewis.
All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
